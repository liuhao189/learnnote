# 软件构建中的设计

## 设计中的挑战

软件设计一次意味着去构思，创造或发明一套方案，把一份计算机软件的规格说明书要求转变为可实际运行的软件。

设计就是把需求分析和编码调试连在一起的活动，好的高层设计能提供一个可以稳妥容纳多个较低层次设计的结构。

### 设计是一个险恶的问题

险恶的问题就是那种只有通过解决或部分解决才能被明确的问题。必须首先把这个问题解决一遍以便能够明确地定义它，然后再次解决该问题，从而形成一个可行的方案。

### 设计是个了无章法的过程

软件设计的成果应该是组织良好，干净利落的，然而形成这个设计的过程却并非如此清爽。

犯错正是设计的关键所在，在设计阶段犯错并加以改正，其代价要比在编码后才发现同样的错误并彻底修改低得多。

优劣设计之间的差异往往非常微妙。

### 设计就是确定取舍和调整顺序的过程

设计者的一个关键内容便是去衡量彼此冲突的各项设计特性，并尽力在其中寻求平衡。

### 设计受到诸多限制

设计的要点，一部分是在创造可能发生的事情，而另一部分又是在限制可能发生的事情。

### 设计是不确定性的

三个人设计一套同样的程序，很可能会做出三套截然不同的设计，而每套设计都很不错。

### 设计是一个启发式的过程

正因为设计过程充满了不确定性，因此设计技术也就趋于具有探索性，经验法则。

### 设计是自然而然形成的

设计实在不断的设计评估，非正式讨论，写试验代码以及修改试验代码中演化和完善的。

# 关键的设计概念

## 软件的首要技术使命：管理复杂度

### 偶然的难题和本质的难题

两类不同的问题导致软件开发变得困难：本质的问题和偶然的问题。

在哲学界，本质的属性是一件事物必须具备，如果不具备就不再是该事物的属性。偶然的属性则是指一件事物碰巧具有的属性，有没有这些属性都并不影响这件事物本身。

偶然性难题在很久以前就已经得到解决了。在软件开发剩下的那些本质性苦难上的进展将会变得相对缓慢。

本质上说软件开发就是不断地去发掘错综复杂，相互连接的整套概念的所有细节。当软件要解决更大规模的显示问题时，现实的实体之间的交互行为就变得更为复杂。转而又增加软件解决方案的本质性困难。

### 管理复杂度的重要性

导致软件项目失败的原因，很少把技术原因归为项目失败的首要因素，项目的失败大多数都是由差强人意的需求，规划和管理所导致的。

当项目确由技术因素导致失败时，其原因通常就是失控的复杂度。有关的软件变得极端复杂。

管理复杂度是软件开发中最为重要的技术话题，软件的首要技术使命便是管理复杂度，它是在是太重要了。

没有谁的大脑能容得下一个现代的计算机程序，作为软件开发人员，我们不应该试着去同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分。

软件架构的层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。所有软件设计技术的目标都是把复杂问题分解成简单的部分。子系统间的相互依赖越少，你就越容易在同一时间里专注问题的一小部分。精心设计的对象关系使关注点相互分离，从而使你能在每个时刻只专注于一件事情。

保持子程序的短小精悍也能帮助你减少思考的负担。从问题的领域着手，而不是从底层实现细节入手去编写程序，在最抽象的层次上工作，也能减少人的脑力负担。

### 如何应对复杂度

高代价，低效率的设计源于下面三种根源：用复杂的方法解决简单的问题；用简单但错误的方法解决复杂的问题；用不恰当的复杂方法解决复杂的问题。

用下面的这两种方法来管理复杂度：

把任何人在同一事件需要处理的本质复杂度的量减到最少；不要让偶然性的复杂度无谓地快速增长。

## 理想的设计特征

高质量的设计具有很多常见的特征，一系列相互竞争的目标之中作出一套最好的折中方法。

### 最小的复杂度

设计的首要目标就是让复杂度最小，避免做出聪明的设计，因为聪明的设计常常都是难以理解的。应该作出简单且易于理解的设计。

### 易于维护

易于维护意味着在设计时为做维护工作的程序员着想。设计出能自明的系统。

### 松散耦合

松散耦合意味着在设计时让程序的各个组成部分之间关联最小。通过应用类接口中的合理抽象，封装性及信息隐藏等原则，设计出相互关联尽可能少的类。

### 可扩展性

可扩展性是说你能增强系统的功能而无需破坏其底层结构。可以改动系统的某一部分而不会影响到其它部分。

### 可重用性

设计的系统的组成部分能在其它系统中重复使用。

### 高扇入

让大量的类使用某个给定的类，意味着设计出的系统很好地利用了在较低层次上的工具类。

### 低扇出

让一个类里少量或适中地使用其它的类，高扇出说明一个类使用了大量其它的类，变得过于复杂。

### 可移植性

可移植性是说应该这样设计系统，使它能很方便地移植到其它环境中。

### 精简性

精简性意味着设计出的系统没有多余的部分。一本书的完成，不在于它不能再加入任何内容的时候，而在于不能再删去任何内容的时候。

### 层次性

层次性意味着尽量保持系统各个分解层的层次性，使你能在任意的层面上观察系统，并得到某种具有一致性的看法。

### 标准技术

一个系统所依赖的外来的，古怪的东西越多，别人在第一次想要理解它的时候就越是头疼。要尽量用标准化的，常用的方法，让整个系统给人一种熟悉的感觉。

## 设计的层次

需要在一个软件系统中的若干不同细节层次上进行设计。有些设计技术适用于所有的层次，而有些只适用于某些层次上。

### 软件系统

第一个层次就是整个系统，有的程序员直接从系统层次就开始设计类，但是往往先从子系统或包这些类的更高组织层次来思考会更有益处。

### 分解为子系统或包

在这一层次上设计的主要成果是识别出所有的主要子系统，这些子系统可能会很大，比如说数据库，用户界面，业务规则，命令解释器，报表引擎等。这一层的主要设计活动就是确定如何把程序分为主要的子系统，并定义清楚允许各子系统如何使用其它子系统。

不同子系统之间相互通信的规则，如果所有的子系统都能同其它子系统通信，你就失去了把它们分开所带来的好处，应该通过限制子系统之间的通信来让每个子系统更有存在意义。

为了让子系统之间的连接简单易懂且易于维护，就要尽量简化子系统之间的交互关系。系统层次设计图应该是无环图。

## 第二层常用的子系统

### 业务规则

业务规则是指那些在计算机系统中编入的法律，规则，政策以及过程。

### 用户界面

应创建一个子系统，把用户界面组件同其它部分分隔开，以便使用户界面的演化不会破坏程序的其余部分。

### 数据库访问

把对数据库进行访问的实现细节隐藏起来，让程序的绝大部分可以不必关心处理底层结构的繁琐细节，并能像在业务层次一样处理数据。

隐藏实现细节的子系统可以为系统提供有价值的抽象层，从而减少程序的复杂度。

### 对系统的依赖性

把对操作系统的依赖因素归到一个子系统里，就如同把对硬件的依赖因素封装起来一样。

## 第三层分解为类

在这一层次上的设计包括识别出系统中所有的类。把所有的子系统进行适当的分解，并确保分解出的细节都恰到好处，能够用单个的类实现。

类和对象的比较：对象是指运行期间在程序中实际存在的具体实体，对象是动态的，拥有你在程序运行期间所能得到的具体的值和属性；而类是指在程序源码中存在的静态事务。

## 第四层分解成子程序

这一层的设计包括把每个类细分为子程序。细化出类的私用子程序。完整地定义出类内部的子程序，常常会有助于更好地理解类的接口。

留给程序员个人来完成的。

## 第五层子程序内部的设计

在子程序层次上进行就是为每个子程序布置详细的功能。子程序内部的设计工作通常是由负责该子程序的开发人员来完成的。

编写伪代码，选择算法，组织子程序内部的代码块，以及用编程语言编写代码。

