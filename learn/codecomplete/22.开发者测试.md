# 开发者测试

测试是最常见的改善质量的活动，这种实践得到许多业界和学界研究，以及商业经验的支持。

单元测试，将一个完整的类，子程序或小程序，从完整的系统中隔离出来进行测试。

组件测试，将一个类、包、小程序或者其它程序元素，从一个更加完整的系统中隔离出来进行测试。这些被测试代码涉及到多个程序员或多个团队。

集成测试，对两个或更多的类，包，组件或者子系统进行的联合测试。

回归测试，重复执行以前的测试用例，以便在原先通过了相同测试集合的软件中查找缺陷。

系统测试，在最终的配置下运行整个软件，以便测试安全，性能，资源消耗，时序方面的问题，以及其它无法在低级集成上测试的问题。

开发者测试主要包括单元测试，组件测试和低级别集成测试。有时还会包括回归测试和系统测试。

测试通常分为两大类，黑盒测试和白盒测试。黑盒测试指的是测试者无法了解测试对象内部工作机制的测试。白盒测试指的是测试者清楚待测试对象内部工作机制的测试。

## 开发者测试在软件质量中的角色

测试的目标与其它开发活动背道而驰，测试的目标是找出错误。其它开发活动的目标是避免程序错误和软件的崩溃。

测试永远不可能彻底证明程序中没有错误。测试本身并不能改善软件的质量。

测试时要求你假设会在代码里面找到错误。

所有的测试应该占整个项目的50%的时间。开发者测试应该占整个项目的8%-25%之间，如果不包含调试，占用的时间会少一些。

测试结果用于评估正在开发的产品的可靠性，还可以用于指导对软件的修正。归纳出程序中最常见的错误的类型，选择适当的培训课程，指引今后的技术复查活动，设计未来的测试用例。

## 构建中测试

玻璃盒测试，除了观察它的输入输出，还要查看内部的源代码。知道盒子里面的情况，可以更彻底地测试这个类。

一部分同其它部分组合之前，都需要对它进行彻底的单元测试。独立进行子程序的测试不是一件容易的事情，但是单独调试它们，比集成之后再进行测试要简单得多。

## 开发者测试的推荐方法

对每一项相关的需求进行测试，以确保需求都已经被实现。对需求里面常见的疏漏进行测试。

对每一个相关的设计关注点进行测试，以确保设计已经被实现。

用基础测试来扩充针对需求和设计的详细测试用例。增加数据流测试，然后补充其它所需的测试用例，以便对代码进行彻底的考验。

使用一个检查表，其中记录着你在本项目迄今为止所犯的，以及在过去的项目中所犯的错误类型。

## 测试先行还是测试后行

首先编写测试用例，更早发现缺陷，更容易修正它们。写代码之前至少思考一下需求和设计。需求上的问题暴露出来。仍然可以最后再进行测试。

## 开发者测试的局限性

开发者测试倾向于干净测试，开发者往往去做一些检验代码能否工作的测试，而不是做所有可能让代码失效的测试。

开发者测试对覆盖率有过于乐观的估计，开发者坚信他们的测试覆盖率达到了95%。

开发者测试往往会忽略一些更复杂的测试覆盖率类型。100%分支覆盖率。

# 测试技术锦囊

## 不完整的测试

由于进行完全测试实际上是不可能的，测试的窍门就在于选择那些最有可能找到错误的测试用例。

## 结构化的基础测试

结构化的基础测试其实是一个相当简单的概念，其思想是，你需要去测试程序中的每一条语句至少一次。如果语句是一个逻辑语句，例如if语句或者while语句，需要根据if或者while中表达式的复杂程度来修改测试，以确保这个语句完全经过了测试。

代码覆盖测试或者逻辑覆盖测试，这是测试程序里所有路径的两种方法。

所需基础测试用例的最少数量，可以通过下面的简单方法计算。

1、对通过子程序的直路，开始的时候记1。

2、遇到下面的每个关键字或其等价物时，加1，if，while，repeat，for，and以及or。

3、遇到每一个case语句加1，如果case语句每一条缺省情况，再加1。

## 数据流测试

控制流和数据流在计算机程序设计中的重要性不分伯仲。

数据使用的出错几率至少不亚于控制流，全部代码中至少有一半是数据声明和初始化。

数据状态：已定义；已使用；已销毁。已进入，控制流已经进入一个子程序；已退出，对变量产生影响之后，控制流立即退出子程序。

编写数据流测试用例的关键是要对所有可能的定义-使用路径进行测试，可以采用彻底程度不同的测试。

## 等价类划分

等价类划分的概念是这一想法的严格表达形式，应用它有助于减少所需用例的数量。

## 猜测错误

优秀的程序员会使用各种不太规矩的，启发式的方法去寻找它们代码中的错误。其中一种启发式方法就是猜测错误。猜测程序会在哪里出错的基础之上建立测试用例。

猜测可以基于直觉或者过去的经验。

## 边界值分析

边界条件进行测试最丰硕的战果之一就是off-by-one错误。边界值分析的思想就是写一些测试用例来测试边界值条件。

## 符合边界值

边界值分析也适用于允许的最大值最小值。

## 几类坏数据

数据太少，太多的数据，错误的数据情况，长度错误的数据，未初始化的数据。

## 几类好数据

正常的情况，最小的正常局面，最大的正常局面，与旧数据的兼容性。新程序或子程序替代旧版本的时候才需要进行。

## 采用容易手工检查的测试用例

简单数据容易脑算。

## 典型错误

你越了解你的对手-错误，你的测试就有可能做得更好。

## 哪些类包含最多的错误

项目中部分子程序占用了大量的开发成本，缺陷并不是平均分布的。这些子程序的成本的确是异常高昂的。

维护工作应该围绕如何确定容易出问题的子程序，如何把这些部分推倒重来，重新设计并编写代码。

## 错误的分类

大多数错误的影响范围是相当有限的。

许多错误发生在构建的范畴之外。

大多数的构建期错误是编程人员的失误造成的。

笔误拼写错误是一个常见的问题根源。

研究程序员所犯错误原因时，错误理解设计这条经常出现。

大多数错误都很容易修正。

总结所在组织中对付错误的经验。

## 不完善的构建过程引发错误所占的比例

在小型项目里面，构建中的缺陷占了所有错误的大多数。

无论项目规模如何，构建缺陷至少占了总缺陷的35%。总体来说，对于应用领域的理解越好，所涉及的总体架构也就越好。

修正构建错误的代价虽然要比修正需求和设计的相对低廉，但从绝对值来看仍然是高昂的。

## 你期望能发现多少错误

已发现的软件中平均1000行代码发现1-25个错误。

微软应用程序部门的经验是，内部测试程序大约每1000行代码有10-20个缺陷，已发布产品则大约是1000行代码.5个缺陷。

少数几个项目，能够达到每50万行代码0缺陷的水平，这需要使用一个系统的形式化开发方法，同事复查，以及统计测试。

TSP和净室开发项目的结论从另一个角度证明了软件质量的普遍原则，开发高质量的软件，比开发低质量的软件然后修正的成本要低廉。源泉在于使用TSP或者净室技术的项目几乎没有将时间投入到调试当中。

## 测试本身的错误

测试用例可能包含同被测试代码同样多，甚至是更多的错误。测试用例没有警告仔细的设计和构建。

检查你的工作，开发代码般的谨慎态度来开发测试用例，这种谨慎当然包括对代码进行双重检查。

开发软件的时候就要计划好测试用例，需求阶段或者刚接手该程序时，就应该开始对测试作出有效的计划。

保留你的测试用例，管理测试用例，把它们保存起来，回归测试或者开发下一个版本的时候还用得上。

将单元测试纳入测试框架，首先写单元测试中使用的代码。

# 测试支持工具

## 为测试各个类构造脚手架

脚手架是个建筑界的术语，建筑工人如果要对建筑的某个部分进行施工，就必须搭建脚手架。软件中搭建脚手架只有一个目的，那就是更方便地测试代码。

有一组脚手架是所谓的哑类，待测试的类可以使用它。这样的类也被称为模仿对象或者。对于底层的子程序也可以用类似的方法，那就是桩函数。

脚手架可以立刻返回控制器，不做任何动作；检查传给它的数据；输出诊断信息，显示所传入的参数，将信息记录到日志文件中；返回用户交互输入的值；不管输入是什么都返回一个标准的响应；消耗原本分配给真实对象或者真实子程序的时钟周期；以某种慢速，臃肿，简单或粗略的方式实现真实对象或者子程序的功能。

另外一种脚手架类型，是调用待测试的真实函数的伪造函数。驱动函数，或测试夹具。

用固定的一组输入调用对象；提示用户输入，然后根据输入去调用对象；从命令行取得参数去调用对象；从文件中读取参数，并据此调用对象。预先定义的输入数据取多次调用有关的对象。

最后一种脚手架是所谓的哑文件，即真实文件的一个小尺寸版本。

## Diff工具

如果你有一个能自动对比实际输出与期望输出的工具，那么进行回归测试就会很容易。

## 测试数据生成器

正确设计的随机数据生成器可以产生让你意想不到的，不寻常的测试数据组合。

比起手工构造测试数据，随机数据生成器可以更加彻底地对程序进行测试。

可以进一步精炼随机生成的测试用例，以强化所生成的输入的真实性。

模块化设计优势，独立于用户界面代码进行测试，使得编写测试缺东程序的工作变得非常简单。

## 覆盖率监视器

没有测量代码覆盖率的测试，通常值测试到了大约50%到60%的代码。覆盖率监视器就是用来跟踪哪些代码已经测试过了。

## 数据记录器&&日志记录器

有些工具可以监视你的程序，并在发生错误的时候为你收集程序状态信息。为诊断错误提供帮助，可以在产品发布之后为客户提供有效的服务。

## 符号调试器

调试器可以一行行地对代码进行单步调试，跟踪变量的值，并能完全按照计算机的方式来演绎代码的执行情况。


