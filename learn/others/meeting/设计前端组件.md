# 写过通用前端组件吗

设计前端组件是最能考验开发者基本功的测试之一，因为调用meterial design、antd、iView等现成组件库的API每个人都可以做到，但是很多人并不知道很多常用组件的设计原理。

能够设计出通用前端组件也是区分前端工程师和前端API调用师的标准之一，那么应该如何设计出一个同样组件呢？

## 前端组件库的设计原则

## 细粒度的考量

学习设计模式的时候会遇到很多种设计原则，其中一个设计原则就是单一职责原则，在组件库的开发中同样适用。

原则上一个组件只专注一件事情，单一职责的组件的好处很明显，由于职责单一就可以最大可能性地复用组件。

但是这也带来一个问题，过度单一职责的组件也可能导致过渡抽象，造成组件库的碎片化。

eg：自动完成组件，其实是由input组件和select组件组合而成的，完全可以复用之前的相关组件。Antd的AutoComplete组件就复用了Select组件，同时Calendar、Form等等一系列组件都复用了Select组件，那么select的细粒度就是合适的，因为Select保持的这种细粒度很容易被复用。

微章数组件，它的右上角会有红点提示，可能是数字也可能是icon，它的职责当然也很单一。这个红点提示也里所当然也可以被单独抽象为一个独立组件，但是我们通常不会将它作为独立组件，因为在其它场景中这个组件是无法被复用的。因为没有类似的场景再需要小红点这个小组件了。所以作为独立组件就属于细粒度过小。

所谓的单一职责组件要建立在可复用的基础上，对于不可复用的单一职责组件仅仅作为独立组件的内部组件即可。

## 通用性考量

设计的本身就是通用组件库，不同于我们常见的业务组件，同样组件是与业务解耦但是又服务于业务开发的。

eg：选择器组件

如果Select组件的最下部需要有一个可拓展的条目的按钮

我们难道要重新修改之前的选择器组件，甚至再造一个符合要求的选择器组件吗？一旦有这种情况发生，那么只能说明之前的选择器组件通用性不够，需要我们重新设计。

Antd的Select组件预留了dropdownRender来进行自定义渲染，其依赖的rc-select组件中的代码。

    Antd依赖了大量以rc-开头的底层组件，这些组件被rect-component团队维护，其主要实现组件的底层逻辑，Antd则是在此基础上添加Ant Desgin设计语言而实现的。

通用性设计其实是一定意义上放弃对DOM的掌控，而将DOM结构的决定权转移给开发者，dropdownRender其实就是放弃对Select下拉菜单中条目的掌控。

Antd的Select组件其实还有一个没有在文档中体现的方法getInputElement应该是对Input组件的自定义方法。Antd整个Select的组件设计非常复杂，基本将所有的DOM结构控制权全部暴露给了开发者，其本身只负责底层逻辑和最基本的DOM结构。

通用性设计在将DOM结构决定权交给开发者的同时也保留了默认结构，在开发者没有显示自定义的时候默认使用默认渲染结构。

    组件的形态DOM结构永远是千变万化的，但是其行为逻辑是固定的，因此通用组件的秘诀之一就是将DOM结构的控制权交给开发者，组件只负责行为和最基本的DOM结构。

# 技术选型

## CSS解决方案

CSS本身的众多缺陷，书写繁琐(不支持嵌套)、样式易冲突(没有作用域概念)、缺少变量(不便于一键换主题)而足。

CSS预处理器SASS、LESS和Stylus，后起之秀PostCSS。再到CSS Modules，Styled-Components等。

不管哪种方案，都需要额外引入css，比如Antd需要这样显示引入，为了缓解这种情况，Antd用Babel插件将这种情况Hack掉。

meterial-ui使用css-in-js的解决方案，jsx的引入已经将js和html耦合，css-in-js也耦合进入，组件便不需要引入css，而是直接引用js即可。

如今的时代是组件化的时代了，jsx已经将js和html框定到一个组件中，css依然处于分离状态，这就导致了每次引用组件却还需要显示引入css，css-in-js正式彻底组件化的解决方案。

## js解决方案

选TypeScript，因为微软大法好。

# 如何快速启动一个组件库项目

组件的具体实现部分当然是组件库的核心，但是现代前端库中其它部分必不可少。需要一堆工具来辅助我们开发。eg：编译工具，代码检测工具工具，打包工具等。

## 打包工具rollup vs webpack

最火爆的当然是需要配置工程师专门配置的webpack，但是在类库开发领域它有一个强大的对手就是rollup。

现代市面上主流的库基本都选择了rollup作为打包工具，包括Angular React和Vue。

Rollup的优势如下：

1、Tree Shaking，自动移除未使用的代码，输出更小的文件。

2、Scope Hoisting，所有模块构建在一个函数内，执行效率更高。

3、Config文件支持通过ESM模块格式书写，可以一次输出多种格式。

4、模块规范，IIFE，AMD，CJS，UMD，ESM Development与prodution版本，js，min.js

虽然上面部分功能已被webpack实现了，但是rollup明显引入得更早，而Scope Hoisting更是杀手锏。

## 代码检测

由于JS的各种诡异的特性和大型前端项目的出现，代码检测工具已经是前端开发者的标配了。

2013年开发的全新的基于AST的Lint工具ESLint，随着ES6的流行统治了前端界。

    TS官方钦点了ESLint，TSLint失宠了，面向未来的官方标配的代码检测工具肯定是ESLint。

代码检测工具是一方面，代码检测风格也需要我们做选择，市面上最流行的代码检测风格应该是Airbnb出品的eslint-config-airbnb。其最大的特点就是极其严格。

大型前端项目的开发中这种严格的代码风格是有利于协作的。

作为一个类库的代码检测工具，使用eslint-config-standard这种相对更为宽松的代码检测风格。

## commit规范

好的commit message不仅有助于他人review，还可以有效输出CHANGELOG，对项目的管理实际至关重要。

目前流行的方案是Angular团队的规范，其关于head的大致规范如下：

type：commit的类型，feat新特性，fix修改问题，refactor代码重构，docs文档修改，style代码格式修改，test测试用例修改，chore其它修改，比如构建流程，依赖管理。

scope：commit的影响范围，route，component，utils，build

subject：commit的概述

body：commit具体修改内容，可以分为多行

footer：一些备注，通常是BREAKING CHANGE或修复的bug的链接

用commitizen将此规范集成到工具流中，每个commit就不得不遵循规范了。

## 测试工具

基础模块库作为被反复依赖的模块和较为稳定的需求是必须做测试的。

Jest作为测试工具，优点很明显。

1、开箱即用，内置断言，测试覆盖率工具

2、快照功能，Jest可以利用其特有的快照测试功能

3、速度优势，Jest的测试用例是并行执行的，只执行发生改变的文件所对应的测试，提升了测试速度。

## 其它

### 快速启动脚手架

专门用于组件开发的快速启动的脚手架。

## 如何设计一个轮播图组件

### 轮播图基本原理

一个视图窗口，overflow属性为hidden隐藏非可视区域的子组件。不断变更transform:translateX来操作。

根据用户交互来触发轮播，移动端通常是通过手指滑动来触发轮播，touchstart，touchmove，touchend。

touchsatrt记录触摸屏幕的开始点。

touchmove判断滑动方向，用户可能向左或向右滑动，轮播图跟随手指一动，必要的用户反馈。

touchend滑动完毕时出发的事件，判断是否触发轮播，设置一个阈值threshold，滑动距离超过这个阈值时才会触发轮播。

### 轮播图的动画效果

不是生硬的切换，一般在轮播图中有一个渐变或者缓动的动画，这就需要我们加入动画效果。

CSS3自带的动画效果，requestAnimationFrame，Animation API。

CSS3简单易用上手快，兼容性好，requestAnimationFrame灵活性更高，能实现CSS3实现不了的动画。

### 改进方向

实现了轮播图的基本功能

1、提示点的自定义，我的实现是一个小点，而antd是用的条，完全可以将dom结构的决定权交给开发者。

2、方向的自定义，本轮播图只有水平方向的实现，其它也可以有纵向轮播。

3、多张轮播

4、性能优化，根据是否被隐藏取消定时器终止自动播放


