<font size="4px">
# 软件构建中的设计

## 设计中的挑战

软件设计意味着去构思，创造或发明一套方案，把一份计算机软件的规格说明书要求转变为可实际运行的软件。

设计就是把需求分析和编码调试连在一起的活动，好的高层设计能提供一个可以稳妥容纳多个较低层次设计的结构。

### 设计是一个险恶的问题

险恶的问题就是那种只有通过解决或部分解决才能被明确的问题。必须首先把这个问题解决一遍以便能够明确地定义它，然后再次解决该问题，从而形成一个可行的方案。

### 设计是个了无章法的过程

软件设计的成果应该是组织良好，干净利落的，然而形成这个设计的过程却并非如此清爽。

犯错正是设计的关键所在，在设计阶段犯错并加以改正，其代价要比在编码后才发现同样的错误并彻底修改低得多。

优劣设计之间的差异往往非常微妙。

### 设计就是确定取舍和调整顺序的过程

设计者的一个关键内容便是去衡量彼此冲突的各项设计特性，并尽力在其中寻求平衡。

### 设计受到诸多限制

设计的要点，一部分是在创造可能发生的事情，而另一部分又是在限制可能发生的事情。

### 设计是不确定性的

三个人设计一套同样的程序，很可能会做出三套截然不同的设计，而每套设计都很不错。

### 设计是一个启发式的过程

正因为设计过程充满了不确定性，因此设计技术也就趋于具有探索性，经验法则。

### 设计是自然而然形成的

设计是在不断的设计评估，非正式讨论，写试验代码以及修改试验代码中演化和完善的。

# 关键的设计概念

## 软件的首要技术使命：管理复杂度

### 偶然的难题和本质的难题

两类不同的问题导致软件开发变得困难：本质的问题和偶然的问题。

在哲学界，本质的属性是一件事物必须具备，如果不具备就不再是该事物的属性。偶然的属性则是指一件事物碰巧具有的属性，有没有这些属性都并不影响这件事物本身。

偶然性难题在很久以前就已经得到解决了。在软件开发剩下的那些本质性苦难上的进展将会变得相对缓慢。

本质上说软件开发就是不断地去发掘错综复杂，相互连接的整套概念的所有细节。当软件要解决更大规模的现实问题时，现实的实体之间的交互行为就变得更为复杂。转而又增加软件解决方案的本质性困难。

### 管理复杂度的重要性

导致软件项目失败的原因，很少把技术原因归为项目失败的首要因素，项目的失败大多数都是由差强人意的需求，规划和管理所导致的。

当项目确由技术因素导致失败时，其原因通常就是失控的复杂度。有关的软件变得极端复杂。

管理复杂度是软件开发中最为重要的技术话题，软件的首要技术使命便是管理复杂度，它是在是太重要了。

没有谁的大脑能容得下一个现代的计算机程序，作为软件开发人员，我们不应该试着去同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分。

软件架构的层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。所有软件设计技术的目标都是把复杂问题分解成简单的部分。子系统间的相互依赖越少，你就越容易在同一时间里专注问题的一小部分。精心设计的对象关系使关注点相互分离，从而使你能在每个时刻只专注于一件事情。

保持子程序的短小精悍也能帮助你减少思考的负担。从问题的领域着手，而不是从底层实现细节入手去编写程序，在最抽象的层次上工作，也能减少人的脑力负担。

### 如何应对复杂度

高代价，低效率的设计源于下面三种根源：用复杂的方法解决简单的问题；用简单但错误的方法解决复杂的问题；用不恰当的复杂方法解决复杂的问题。

用下面的这两种方法来管理复杂度：

把任何人在同一时间需要处理的本质复杂度的量减到最少；不要让偶然性的复杂度无谓地快速增长。

## 理想的设计特征

高质量的设计具有很多常见的特征，一系列相互竞争的目标之中作出一套最好的折中方法。

### 最小的复杂度

设计的首要目标就是让复杂度最小，避免做出聪明的设计，因为聪明的设计常常都是难以理解的。应该作出简单且易于理解的设计。

### 易于维护

易于维护意味着在设计时为做维护工作的程序员着想。设计出能自明的系统。

### 松散耦合

松散耦合意味着在设计时让程序的各个组成部分之间关联最小。通过应用类接口中的合理抽象，封装性及信息隐藏等原则，设计出相互关联尽可能少的类。

### 可扩展性

可扩展性是说你能增强系统的功能而无需破坏其底层结构。可以改动系统的某一部分而不会影响到其它部分。

### 可重用性

设计的系统的组成部分能在其它系统中重复使用。

### 高扇入

让大量的类使用某个给定的类，意味着设计出的系统很好地利用了在较低层次上的工具类。

### 低扇出

让一个类里少量或适中地使用其它的类，高扇出说明一个类使用了大量其它的类，变得过于复杂。

### 可移植性

可移植性是说应该这样设计系统，使它能很方便地移植到其它环境中。

### 精简性

精简性意味着设计出的系统没有多余的部分。一本书的完成，不在于它不能再加入任何内容的时候，而在于不能再删去任何内容的时候。

### 层次性

层次性意味着尽量保持系统各个分解层的层次性，使你能在任意的层面上观察系统，并得到某种具有一致性的看法。

### 标准技术

一个系统所依赖的外来的，古怪的东西越多，别人在第一次想要理解它的时候就越是头疼。要尽量用标准化的，常用的方法，让整个系统给人一种熟悉的感觉。

## 设计的层次

需要在一个软件系统中的若干不同细节层次上进行设计。有些设计技术适用于所有的层次，而有些只适用于某些层次上。

### 软件系统

第一个层次就是整个系统，有的程序员直接从系统层次就开始设计类，但是往往先从子系统或包这些类的更高组织层次来思考会更有益处。

### 分解为子系统或包

在这一层次上设计的主要成果是识别出所有的主要子系统，这些子系统可能会很大，比如说数据库，用户界面，业务规则，命令解释器，报表引擎等。这一层的主要设计活动就是确定如何把程序分为主要的子系统，并定义清楚允许各子系统如何使用其它子系统。

不同子系统之间相互通信的规则，如果所有的子系统都能同其它子系统通信，你就失去了把它们分开所带来的好处，应该通过限制子系统之间的通信来让每个子系统更有存在意义。

为了让子系统之间的连接简单易懂且易于维护，就要尽量简化子系统之间的交互关系。系统层次设计图应该是无环图。

## 第二层常用的子系统

### 业务规则

业务规则是指那些在计算机系统中编入的法律，规则，政策以及过程。

### 用户界面

应创建一个子系统，把用户界面组件同其它部分分隔开，以便使用户界面的演化不会破坏程序的其余部分。

### 数据库访问

把对数据库进行访问的实现细节隐藏起来，让程序的绝大部分可以不必关心处理底层结构的繁琐细节，并能像在业务层次一样处理数据。

隐藏实现细节的子系统可以为系统提供有价值的抽象层，从而减少程序的复杂度。

### 对系统的依赖性

把对操作系统的依赖因素归到一个子系统里，就如同把对硬件的依赖因素封装起来一样。

## 第三层分解为类

在这一层次上的设计包括识别出系统中所有的类。把所有的子系统进行适当的分解，并确保分解出的细节都恰到好处，能够用单个的类实现。

类和对象的比较：对象是指运行期间在程序中实际存在的具体实体，对象是动态的，拥有你在程序运行期间所能得到的具体的值和属性；而类是指在程序源码中存在的静态事物。

## 第四层分解成子程序

这一层的设计包括把每个类细分为子程序。细化出类的私用子程序。完整地定义出类内部的子程序，常常会有助于更好地理解类的接口。

留给程序员个人来完成的。

## 第五层子程序内部的设计

在子程序层次上进行就是为每个子程序布置详细的功能。子程序内部的设计工作通常是由负责该子程序的开发人员来完成的。

编写伪代码，选择算法，组织子程序内部的代码块，以及用编程语言编写代码。

# 设计构造块：启发式方法

对于具体的编程工作来说，期待确定性的行为是很正常的，无论这种对细节的关注会给程序带来好处还是坏处。

由于软件设计是非确定性的，灵活熟练地运用一组有效的启发式方法，便成了合理的软件设计的核心工作。

## 找出现实世界中的对象

确定设计方案时，首选且最流行的一种做法便是常规的面向对象设计方法，此方法的要点是辨识现实世界中的对象以及人造的对象。

辨识对象及其属性，确定可以对各个对象进行的操作，确定各个对象能对其它对象进行的操作，确定对象的可见性，定义每个对象的公开接口。

### 辨识对象及其属性

计算机程序通常都是基于现实世界的实体。深入挖掘问题领域可能会得出更好的设计方案。

### 定义可对对象执行的操作

每个对象上都可以执行多种操作。

### 确定每个对象对其它对象进行的操作

对象之间最常见的两者关系是包含和继承，哪些对象可以包含其它对象，哪些对象又可以从其它对象继承。

### 确定对象的哪些部分对其它对象可见

一项关键的设计决策就是明确对象的哪些部分应该是公开的，哪些部分又应该是不公开的，对数据和方法都要做这一决策。

### 定义每个对象的接口

在编程语言的层次上为每个对象定义具有正式语法的接口。公开的接口和受保护的接口。

经过上面这些步骤得到了一个高层次的，面向对象的系统组织结构之后，可以在高层次的系统组织结构上进行迭代，以便更好地组织类的结构；或者在每一个定义好的类上进行迭代，把每个类的设计细化。

### 形成一致的抽象

抽象是一种能让你在关注某一概念的同时可以放心地忽略其中一些细节的能力，在不同的层次处理不同的细节。

任何时候当你在堆一个聚合物品工作时，你就在使用抽象了。

基类也是一种抽象，它使得你能集中精力关注一组派生类所具有的共同特性，并在基类的层次上忽略各个具体派生类的细节。

一个好的接口也是一种抽象，它能让你关注与接口本身而不是类的内部工作方式。

以复杂度的观点看，抽象的主要好处就在于它使你能忽略无关的细节。

### 封装实现细节

封装填补了抽象留下的空白，抽象是说，可以让你从高层的细节来看待一个对象。而封装则说，除此之外，你不能看到对象的任何其它细节层次。

### 继承能简化设计时就继承

定义这种对象之间的相同点和不同点就叫继承。继承的好处在于它能很好地辅佐抽象的概念。继承能简化编程的工作，因为你可以写一个基本的子程序来处理只依赖于门的基本属性的事项。

运行期间才能确定所针对的对象的实际类型的操作，这种能力叫做多态。继承是面向对象编程中最强大的工具之一。

### 隐藏秘密信息隐藏

信息隐藏是结构化程序设计与面向对象设计的基础之一。结构化设计里面的黑盒子概念就是源于信息隐藏，在面向对象设计中，它又能引出了封装和模块化的概念，并与抽象的概念紧密相关。

信息隐藏是软件的首要技术使命中格外重要的一种启发式方法，因为它强调的就是隐藏复杂度。

秘密和隐私权：当信息被隐藏后，每个类都代表了某种对其它类保密的设计或构建决策。隐藏起来的可能是某个易变的区域，或者某种文件格式，或某种数据类型的实现方式，或某个需要隔离的区域。类的职责是把这部分信息隐藏起来，并保护自己的隐私权。

设计一个类的时候，一项关键性的决策就是确定类的哪些特性应该对外可见，而哪些特性应该隐藏起来。

### 两种秘密

信息隐藏中所说的秘密主要分为两大类：

隐藏复杂度：这样你就不用再去应付它，除非你要特别关注的时候

隐藏变化源：这样当变化发生时，其影响就能被限制在局部范围内。

### 信息隐藏的障碍

信息隐藏是根本不可能的，惯用某些技术而导致的心理障碍。

信息过渡分散，信息在系统中过度分散。eg：魔法字符串，人机交互子系统。

循环依赖，无法单独测试。

把类内数据误认为全局数据，并避免使用它，全局变量会让你陷入很多编程陷阱。

子程序在全局数据之上执行操作，不知道其它子程序也在用这些全局数据进行操作。

子程序无法明确地知道其它子程序都进行了哪些操作。

可以察觉的性能损耗：视图在系统架构层和编码层均避免性能上的损耗。编码层为性能目标所做的最好的准备，便是作出高度模块化的设计来，等你日后找出性能的瓶颈，针对个别的类或者函数进行优化而不会影响系统的剩余部分了。

### 信息隐藏的价值

信息隐藏有着独特的启发力，它能够激发出有效的设计方案。

信息隐藏同样有助于设计类的公开接口。eg：等同于找出使用最方便的那个接口，这通常就导致类内部过多的内容被暴露出来。

在设计的所有层面上，都可以通过询问该隐藏什么来促成好的设计决策。

## 找出容易改变区域

优秀的设计师一份研究表明，他们所共有的一项特质就是都有对变化的预期能力。好的程序设计所面临的最重要的挑战之一就是适应变化，目标应该是把不稳定的区域隔离出来，从而把变化所带来的影响限制在一个函数，类或包的内部。

1、找出看起来容易变化的项目；需求应该包含一份潜在变化的清单，以及其中每一项变化发生的可能性。

2、把容易变化的项目分离出来；把第一步中找出的容易变化的组件单独划分成类，或者和其它容易同时发生变化的组件划分到同一个类。

3、把容易变化的项目隔离开来；设计好类之间的接口，使其对潜在的变化不敏感。

### 容易发生变化的区域

业务规则：业务规则很容易成为软件频繁变化的根源。遵循信息隐藏的原则，那么基于这些业务规则的逻辑就不应该遍布于整个程序。

对硬件的依赖性：对屏幕，打印机，键盘，鼠标，硬盘，声音设施以及通信设计等之间的接口都是硬件依赖的例子。

输入和输出：做比硬件接口层稍高一些层面上的设计时，输入输出是一个容易变化的区域。

非标准的语言特性：大多数编程语言的实现中都包含一些便利的，非标准的扩展。

困难的设计区域和构建区域：把困难的设计区域和构建区域隐藏起来也是很好的想法，因为设计地很差而需要重新做。把它们隔离起来。

状态变量：状态变量用于表示程序的状态，与大多数其它的数据相比，这种东西更容易改变。请使用枚举类型，使用访问子程序。

数据量的限制：信息隐藏向使用具名常量MAX_EMPLOYEES来隐藏100一样简单。

### 预料不同程序的变化

如果一种变化很可能发生，那么要确保系统能够很容易地对它做出响应。

找出容易发生变化的区域的一个好办法是，首先找出程序中可能对用户有用的最小子集。这一子集构成了系统的核心，不容易发生改变。

## 保持松散耦合

耦合度表示类与类之间或者方法与方法之间关系的紧密程度。耦合度设计的目标是创建出小的，直接的，清晰的类或方法，使它们与其它类或子程序之间关系尽可能地灵活。这就被称作松散耦合。

模块之间好的耦合关系会松散到恰好能使一个模块能够很容易地被其它模块使用。

尽量使你创建的模块不依赖或者少依赖其它模块，让模块之间的关系像商业合作者一样彼此分离。

## 耦合标准

规模：模块之间的连接数。对于耦合度来说，小就是美。

可见性：可见性指的是两个模块之间的连接的显著程度。通过参数表来传递数据便是一种明显的连接，通过修改全局数据而使另一模块能够使用该数据则是一种鬼鬼祟祟的做法，因此是很不好的设计。

灵活性：灵活性指的是模块之间的连接是否容易改动，喜欢热插拔USB连接器，灵活性是其它几个耦合特性综合作用的结果。可以让一个不友好的模块变友好，只要把它变得更灵活。

一个模块越容易被其它模块所调用，那么它们之间的耦合关系就会越松散。更灵活，更易于维护。

## 耦合的种类

1、简单数据参数耦合：当两个模块之间通过参数来传递数据，并且所有的数据都是简单数据类型。这两个模块之间的耦合关系就是简单数据参数耦合的，这种耦合关系是正常的，可以接受的。

2、简单对象耦合：一个模块实例化一个对象，它们之间的耦合关系就是简单对象耦合的。这种耦合关系也很不错。

3、对象参数耦合：两个模块通过对象参数来传递数据，这种耦合关系要更紧密一些。

4、语义上的耦合：一个模块不仅使用了另一模块的语法元素，而且还使用了有关那个模块内部工作细节的语义知识。语义上的耦合是非常危险的，因为更改被调用的模块中的代码可能会破坏调用它的模块，破坏的方式是编译器完全无法检查的。

    Module1向Module2传递了一个控制标志，用它来告诉Module2该做什么。
    Module2在Module1修改了某个全局数据之后使用该全局数据。
    Module1的接口要求他的Module1.Initializa子程序必须在它的Module1.Routine之前得到调用。Module2知道Module1.Routine无论如何都会调用Module1.Init。
    Module1把Object传给Module2，由于Module1指导Module2只用了Object的7个属性中的3个，因此它只部分地初始化Object。
    Module1把BaseObject传给Module2，Modle2知道Module1实际上传给它的是DerivedObject，所以转换成并调用DerivedObject特有的方法。

松散耦合的关键之处在于，一个有效的模块提供出了一层附加的抽象，降低了整体系统的复杂度。模块所具有的管理复杂度的能力才会发挥作用。

类和子程序是用来降低复杂度的首选和最重要的智力工具。

## 查阅常用的设计模式

设计模式通过提供现有的抽象来减少复杂度。

设计模式通过把常见解决方案的细节予以制度化来减少出错。

设计模式通过提供多种设计方案而带来启发性的价值。

设计模式通过把设计对话提升到一个更高的层次上来简化交流。

陷阱：如果一段代码作出巨大改动，迫使它去符合某个标准模式，有时反而会把问题复杂化。

## 其它的启发式方法

### 高内聚性

内聚性指的是类内部的子程序或者子程序内的所有代码在支持一个中心目标上的紧密程序。这个启发式方法的目标就是使内聚性尽可能地高。
内聚性是用用来管理复杂度的有用工具。

### 构造分层结构

分层结构指的是一种分层的信息结构，其中最通用的或者最抽象的概念表示位于层次关系的最上面，而越详细的具有特定意义的概念表示放在更低的层次中。分层结构用作管理复杂信息的重要工具已经至少有2000年。人类使用大纲来组织复杂的信息。

### 严格描述类契约

另一个更为细节的层次上，把每个类的接口看作是与程序的其余部分之间的一项契约会有助于更好地洞察程序。

### 分配职责

另一个启发式方法是去想该怎么为对象分配职责。问每一个对象该对什么负责，类似于问这个对象应该隐藏什么信息。

### 为测试而设计

为了便于测试而设计这个系统。更规整的类接口。

### 避免失误

不要只关注此前的成功案例，而没有充分考虑可能的失败模式。

### 有意识地选择绑定时间

绑定时间指的是把特定的值绑定到某一变量的时间。

### 创建中央控制点

他最关心的就是唯一一个正确位置的原则，对于每一段有作用的代码，应该只有唯一的一个地方可以看到它，并且也只能在一个正确的位置去做可能的维护性修改。

### 考虑使用蛮力突破

蛮力也是一种强大的启发式工具，一个可行的蛮力解决方案要好于一个优雅但却不能用的解决方案，因为优雅的方案可能要花很长时间才能调通。

### 画一个图

画图是另一种强大的启发式方法，一幅画顶得上一千句话，图能够在一个更高的抽象层次上表达问题。

### 保持设计的模块化

模块化的目标是使得每个子程序或者类看上去像个黑盒子。

## 设计启发的总结

1、寻找现实世界的对象

2、形成一致的抽象

3、封装实现细节

4、在可能的情况下继承

5、藏住秘密，信息隐藏

6、找出容易改变的区域

7、保持松散耦合

8、探寻同样的设计模式

9、高内聚性

10、构造分层结构

11、严格描述类契约

12、分配职责

13、为测试而设计

14、避免失误

15、有意识地选择绑定时间

16、创建中央控制点

17、考虑使用蛮力

18、画一个图

19、保持设计模块化

## 设计实践

### 迭代

有时候你会从开发某个程序中学到很多的知识，多得让你想带着写第一遍时所获得的体会再写一遍。设计一个迭代过程。

很多人对在高层和底层思考之间的升降感到困惑，从系统的一个视角转到另一个视角对于创建有效的设计方案而言却是极其重要的。

### 分而治之

把程序分解为不同的关注区域，然后分别处理每一个区域。增量式的改进是一种管理复杂度的强大工具。

理解问题，形成计划，执行计划，而后再回顾你的做法。

### 自上而下和自下而上的设计方法

它们为创建面向对象设计方案提供了很有价值的认识。

自上而下设计从某个很高的抽象层次开始，定义出基类或其它不那么特殊的设计元素，然后逐渐增加细节的层次，找出派生类，合作类以及其他更细节的设计元素。

自下而上的设计始于细节，向一般性延伸，这种设计通常是从寻找具体对象开始，最后从细节之中生成对象以及基类。

自上而下的论据：同一时间只能集中关注一定量的细节，如果你从一般的类出发，一步步地把它们分解称为更具体的类。大脑就不会被迫同时处理过多的细节。

持续分解，直到看起来在下一层直接编码要比分解更容易。

自下而上的论据：找出一些能够分配给具体类的底层的职责。设计问题中的一些主要属性是由底层决定的。

### 其实并没有争议

自上而下策略是一种分解策略，从一般性的问题出发，把该问题分解成可控的部分。

自下而上策略是一种合成策略，后者从可控的部分出发，去构造一个通用的的方案。

### 建立实验性原型

有些时候，除非你更好地了解了一些实现细节，否则很难判断一种设计方法是否奏效。建立原型指的是写出用于回答特定设计问题的，量最少且能够随时扔掉的代码。

### 合作设计

不论组织形式的正式与否，可以与他人合作设计，目标是提高创造力并引入更多的备选设计方案，不仅仅是找到缺陷，那么结构化程度较低的一些方法则比较适宜。

### 要做多少设计才够

设计应该做得多正规，需要正式的，精美的设计文档，还是画在白板上的设计草图。实施正式编码前的设计工作量和设计文档的正规程度，很难有个准确的定论。有很多因素，团队的经验，系统的预期寿命，想要得到的可靠度，项目的规模和团队的大小等等都需要考虑进去。

### 记录你的设计成果

传统的大型的记录设计成果的方式是把它写成正式的设计文档。对于小型的，非正式的项目可以使用其它方式。

把设计文档插入到代码里，代码注释中写明关键的设计决策，这种注释通常放在文件或类的开始位置。

用wiki来记录设计讨论和决策。

写总结邮件，指派某人来写出刚才讨论的纲要，特别是那些决定下来的事项，然后发送给整个项目组。

使用数码相机，工作量只是用画图工具设计图表的1%，它的收益却能达到保存设计图表的80%。

保留设计挂图，张贴在项目工作区域的墙上，让大家很容易地随时查阅和修改。

使用CRC卡片，在适当的细节层创建UML图。

## 对流行的设计方法的评价

请把设计看成是一个险恶的，杂乱的和启发式的过程，你在应用某种设计方法时越教条化，你所能解决的现实问题就会越少。

