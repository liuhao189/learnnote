# 可以工作的类

计算时代的早期，程序员基于语句思考编程问题；七八十年代，程序员开始基于函数去思考编程；21世纪，程序员以类为基础思考编程问题。

类是由一组数据和子程序构成的集合，这些数据和子程序共同拥有一组内聚的，明确定义的职责。成为高效程序员的一个关键就在于，当你开发程序任一部分的代码时，都能安全地忽略程序中尽可能多的其余部分。

## 类的基础：抽象数据类型ADTS

抽象数据类型ADT是指一些数据以及对这些数据所进行的操作的集合。这些操作既向程序的其余部分描述了这些数据是怎么样的，也允许程序的其余部分改变这些数据。

你可以把抽象数据类型想象成一个定义有一组操作的数学模型。


### 用到ADT的例子

调用方代码直接控制数据成员，无疑限制了currentFont的使用。

可以隐藏实现细节：把关于字体数据类型的信息隐藏起来，意味着如果数据类型发改变，你只需在一处修改而不会影响到整个程序。

改动不会影响到整个程序：如果想让字体更丰富，而且能支持更多操作，只需在程序的一处进行修改即可。

让接口能提供更多信息

更容易提高性能：如果你想提高程序性能，就可以重新编写出一些更好的子程序，而不用来回修改整个程序。

让程序的正确性更显而易见，程序更具自我说明性。

无需在程序内到处传递数据，可以像显示世界中的那样操作实体，而不用在底层实现上操作它。

把常见的底层数据类型创建为ADT并使用这些ADT，而不再使用底层数据类型。把向文件这样的常用对象当作ADT。

简单的事物也可当做ADT，不要让ADT依赖于其存储介质，尽量让类和访问器子程序的名字与存储数据的方式无关。

### 在非面向对象环境中用ADT处理多份数据实例

面向对象的编程语言能自动支持对同一ADT的多份实例的处理。向C语言这样的非面向对象的环境中工作，你就必须自己手工实现支持多个实例的技术。

每次使用ADT服务子程序都明确地指明实例，把fontId传给每个用来操作字体的子程序。

明确地向ADT服务子程序提供所要用带的数据。向程序的其余部分暴露了字体内部的数据，从而增加了调用方代码可能利用ADT内部实现细节的可能性。

使用隐含实例，使用多个实体更加顺畅，对于复杂的应用程序来说，这种系统范围内对状态的依赖性就意味着，你必须在用到字体操作的所有代码中跟踪当前的字体实例。

抽象数据类型构成了类这一概念的基础。类还涉及到继承和多态这两个额外的概念，因此，考虑类的一种方式，就是把它看做是抽象数据类型再加上继承和多态两个概念。


## 良好的类接口

创建高质量的类，第一步也是最重要的一步就是创建一个好的接口，这也包括了创建一个可以通过接口来展现的合理的抽象，并确保细节仍被隐藏在抽象背后。

### 好的抽象

抽象是一种以简化的形式来看待复杂操作的能力，类的接口为隐藏在其后的具体实现提供了一种抽象。

一个没有经过良好抽象的类可能会包含有大量混杂的函数，类的接口不能展现出一种一致的抽象，因此它的内聚性就很弱，应该把这些子程序重新组织到几个职能更专一的类里去，在这些类的接口中提供更好的抽象。

1、类的接口应该展现一致的抽象层次，在考虑类的时候有一种很好的方法，就是把类看做一种用来实现抽象数据类型的机制ADT。每一个类应该实现一个ADT，并且仅实现这个ADT。

出现这种混合的抽象，通常是源于程序员使用容器类或其它类库来实现内部逻辑，但却没有把使用类库这一事实隐藏起来。

继承是一个is a的关系，如果类对象的抽象是它能够被搜索或排序，这些功能就应该被明确而一致地包含在类的接口之中。

2、一定要理解类所实现的抽象是什么，必须非常仔细地理解类的接口应该实现的抽象到底是哪一个。

3、提供成对的服务，大多数操作都有和其相应的，相等的以及相反的操作。

4、把不相干的信息转移到其它类中，某个类中一半子程序使用着该类的一半数据，而另一半子程序则使用另一半数据。

5、尽可能让接口可编程，而不是表达语义。可编程的部分由其中的数据类型和其它属性构成，编译器能强制性地要求它们，而语义部分则由本接口将会被怎样使用的假定组成。要想办法把语义接口的元素转换为编程接口的元素，比如用断言或其它的技术。

6、谨防在修改时破坏接口的抽象，对类进行修改和扩展的过程中，常常会发现额外所需的一些功能。这些功能并不十分适应于原有的类接口。

7、不要添加与接口抽象不一致的公共成员，这个子程序与现有接口所提供的抽象一致吗？

8、同时考虑抽象性和内聚性，抽象性和内聚性这两个概念之间的关系非常紧密。

### 良好的封装

封装是一个比抽象更强的概念，抽象通过提供一个可以让你忽略实现细节的模型来管理复杂度，而封装则强制阻止你看到细节。

1、尽可能地限制类和成员的可访问性，可访问性尽可能低是促成封装的原则之一，某个子程序的可访问性应该设为公共，私有或者受保护时，经验之举是采用最严格的且可行的访问级别。

2、不要公开暴露成员数据，暴露成员数据会破坏封装性，从而限制你对这个抽象的控制能力。

3、避免把私用的实现细节放入类的接口中。

4、不要对类的使用者做出任何假设，类的设计和实现应该符合在类的接口中所隐含的契约。

5、避免使用友元类

6、不要因为一个子程序仅使用公用子程序，就把它归入公开接口。接口所展示的抽象是否还是一致的。

7、让阅读代码比编写代码更方便，阅读代码的次数要比编写代码多得多，为了编写代码更方便而降低代码的可读性是非常不经济的。

8、要格外警惕从语义上破坏封装性。每当你发现自己是通过查看类的内部实现来了解该如何使用这个类的时候，你就不是针对接口编程了，而是在透过接口针对内部实现编程了。

9、留意过于紧密的耦合关系，耦合是指两个类之间关联的紧密程度，通常关联越松越好。

## 有关设计和实现的问题

给类定义合理的接口，对于创建高质量的程序起到了关键作用。然而，类内部的设计和实现也同样重要。

### 包含有一个的关系

包含是一个非常简单的概念，表示一个类含有一个基本数据元素或对象，包含是面向对象编程中的主力技术。

通过包含来实现有一个has-a的关系。

在万不得以时通过private继承来实现有一个的关系。

警惕有超过7个数据成员的类，人们在做其他事情时能记住的离散项目的个数是7+-2个。

### 继承是是一个的关系

继承的概念是说一个类是另一个类的一种特化。继承的目的在于，通过定义能为两个或更多个派生类提供共有元素的基类的方式写出更精简的代码。

对每一个成员函数而言，它应该对派生类可见吗？它应该有默认的实现吗？这一默认的实现能被覆盖吗？

对每一个数据成员而言，应该对派生类可见吗？

用public继承来实现是一个的关系。

要么使用继承并进行详细说明，要么就不要用它。继承给程序增加了复杂度。

遵循Liskov替换原则，派生类必须能通过基类的接口而被使用，且使用者无须了解两者之间的差异。

确保只继承需要继承的部分，派生类可以继承成员函数的接口或实现。如果只是想使用一个类的实现而不是接口，那么就应该采用包含方式，而不该用继承。

不要覆盖一个不可覆盖的成员函数。

把共用的接口，数据及操作放在继承树中尽可能高的位置，接口，数据和操作在继承体系中的位置越高，派生类使用它们的时候就越容易。

只有一个实例的类是值的怀疑的，只需要一个实例，这可能表明设计中把对象和类混为一谈了。

只有一个派生类的基类也是值得怀疑，提前设计，试图去预测未来的需要，而又常常没有真正了解未来到底需要什么。不是创建额外的，没准以后哪天就能用得上的基类，而是让眼下的工作成果尽可能地清晰，简单，直截了当。

派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀疑。

避免让继承体系过深，面向对象的编程方法提供了大量可以用来管理复杂度的技术，然而每种强大的工具都有其危险之处，甚至有些面向对象技术还有可能增加而不是降低复杂度的趋势。

尽量使用多态，避免大量的类型检查

让所有数据都是private，继承会破坏封装。

多重继承，多重继承的用途主要是定义混合体。允许多重接口继承，但只能继承一个类的实现。

### 为什么有这么多关于继承的规则

继承往往会让你和程序员的首要技术使命，即管理复杂度背道而驰。

如果多个类共享数据而非行为，应该创建这些类可以包含的共用对象。

如果多个类共享行为而非数据，应该让它们从共同的基类继承而来，并在基类里定义共用的子程序。

多个类共享行为和数据，应该从一个共同的基类继承而来，并在基类里定义共用的数据和子程序

当你想由基类控制接口时，使用继承，当你自己控制接口时，使用包含。

### 成员函数和数据成员

1、让类中子程序的数量尽可能少，出错率也就越少。过深的继承体系，在一个类中调用了大量的子程序，以及类之间的强耦合等，保持子程序数量最少和其它因素之间权衡一下。

2、禁止隐式地产生你不需要的成员函数和运算符，完全可以通过把构造函数，赋值运算符或者其它成员函数或运算符定义为private，从而禁止调用方代码访问它们。

3、减少所调用不同子程序的数量，类里面的错误数量与类所调用的子程序的总数是统计相关的。

4、对其它类的子程序的间接调用要尽可能少，A对象可以任意调用它自己的所有子程序，如果A对象创建了一个B对象，它也可以调用B对象的任何子程序，但是它应该避免再调用由B对象所提供的对象中的子程序。

5、一般来说，应尽量减少类和类之间相互合作的范围。所实例化的对象的种类，在被实例化对象上直接调用的不同子程序的数量，调用由其它对象返回的对象的子程序的数量。

### 构造函数

1、如果可能，应该在所有的构造函数中初始化所有的数据成员。

2、用私有构造函数来强制实现单例，然后对外提供一个static的GetInstance子程序来访问该类的唯一实例。

3、优先使用深层副本，除非论证可行，才采用浅层副本。浅层副本的动机一般是为了改善性能，但这样做很少会导致显著的性能损失。为了不确定的性能提高而增加复杂度是不妥的，面临选择时，优先使用深拷贝。

## 创建类的原因

### 为现实世界中的对象建模

不是唯一的理由，但它仍然是个很好的理由。把该对象需所需的数据添加到类里面，然后编写一些服务子程序来为对象的行为建模。

### 为抽象的对象建模

建立抽象对象的模型，所谓的抽象对象并不是一个现实世界中的具体对象，但它却能为另外一些具体的对象提供一种抽象。从现实世界的实体中提炼出抽象的概念，这一过程是不确定的，得出恰当的抽象对象是面向对象设计中的一项主要挑战。

### 降低复杂度

创建类的一个最重要的理由便是降低程序的复杂度。创建一个类把信息隐藏起来，无需了解其内部工作原理的情况下使用这个类。

### 隔离复杂度

无论复杂度表现为何种形态，复杂的算法，大型数据集，或错综复杂的通讯协议等，都容易引发错误。一旦错误发生，只要它还在类的局部而未扩散到整个程序中，修复错误就比较容易。

### 隐藏实现细节

想把实现细节隐藏起来的这种愿望本身便是创建类的一个绝佳理由。

### 限制变动的影响范围

把容易变动的部分隔离开来，这样就能把变动所带来的影响限制在一个或少数几个类的范围内。把最容易变动的部分设计成最容易修改的。

### 隐藏全局数据

使用访问器子程序的这条纪律还会促使你去思考有关数据是否就应该是全局的，全局数据原来只是对象的数据而已。

### 让参数传递更顺畅

需要把一个参数在多个子程序之间传递，有可能表明应该把这些子程序重构到一个类里，把这个参数放在对象数据来共享。换一种类的组织方式可能会更好。

### 建立中心控制点

在一个地方来控制一项任务是个好主意，控制可以表现为很多形式。

### 让代码更易于重用

将代码放入精心分解的一组类中，比起把代码全部塞进某个更大的类里面，前者更容易在其它程序中重用。

### 为程序族做计划

预计某个程序会被修改，可以把预计要被改动的部分放到单独的类里，同其它部分隔离开。

### 将相关操作包装到一起

类是把相关操作组合在一起的一种方法，还可以使用包，命名空间等。

### 实现某种特定的重构

## 应该避免的类

避免创建万能类，创建什么都知道，什么都能干的万能类。

消除无关紧要的类，如果一个类只包含数据但不包含行为的话，考虑把这个类降级，让它的数据成员称为一个或多个其它类的属性。

避免用动词命名的类，只有行为而没有数据的类往往不是一个真正的类。

## 要点

类的接口应该提供一致的抽象，很多问题都是由于违背该原则而引起的。

类的接口应该隐藏一些信息，如某个系统接口，某项设计决策，或一些实现细节。

包含往往比继承更为可取，除非你要对is-a的关系建模。

继承是一种有用的工具，但它却会增加复杂度，有违于软件的首要技术使命，管理复杂度。

类是管理复杂度的首选工具，设计类时给予足够的关注，才能实现这一目标。




