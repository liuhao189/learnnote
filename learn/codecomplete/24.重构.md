# 重构

神话：一个管理很完善的软件项目，应该首先以系统化的方法进行需求开发，定义一份严谨的列表来描述程序的功能。设计完全遵循需求，并且完成得相当仔细，这样就让程序员的代码编写工作能够从头至尾直线型地工作。测试通过后即可被抛到脑后，代码被修改的唯一时机就是在软件维护阶段。

现实情况：在初始开发阶段，代码会有实质性的进化。在初始的代码编写过程中，就会出现很多剧烈的改变。即使是管理完善的项目，每个月都有大约25%的需求发生变化，需求的变化将不可避免地导致相关代码的改变-有时是实质性的代码改变。

另一个事实：现在的开发方法增强了代码在构造阶段中改变的潜力，在旧式的软件生命周期中，项目成果与否的关键在于能否避免代码的改变。

# 软件演化的类型

软件演化就像生物进化一样，有些突变对物种是有益的，另外一些则是有害的。良性的软件演化使代码得到了发展，有时演化的力量也会以另一种方式打击你的程序。

区分软件演化类型的关键，就是程序的质量在这一过程中是提高了还是降低了。

第二个标准，就是这样的演化是源于程序构建过程中的修改，还是维护过程中的修改。前者通常由最初的开发人员完成，处于高度动态阶段，出现错误的代价较小。

## 软件演化的哲学

程序员在参与到软件演化时有一个普遍的弱点，这就是将其作为一种并非有意而为的过程。在开发过程中认识到软件演化是无法避免且具有重要意义的现象，并对其细加谋划，就可能使这一过程有益于你的开发。

演化使你的软件开发接近完美的天赐良机，当你迫不得已需要对代码进行改变时，就努力对代码进行改进，这样未来在开发中调整就会更容易。

软件演化的基本准则就是，演化应当提升程序的内在质量。

# 重构简介

要实现软件演化基本准则，最关键的策略就是重构，其定义为在不改变软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改。

## 重构的理由

有时，代码在维护过程中质量会降低，而有时代码在最初诞生的时候就先天不良。

代码重复，重复的代码几乎总是代表着对最初设计里彻底分解方面的一个失误。重复代码违背了DRY（Do not repeat yourself）原则，复制粘贴即设计之谬。

冗长的子程序，很少需要用到长度超过一个屏幕的子程序。改善系统的方法之一就是提升其模块性，增加定义完善、命名准确的子程序，让它们各自集中力量做好一件事情。

循环过长或嵌套过深，循环内部的复杂代码常常具备转换为子程序的潜质，这样的改动将有助于对代码的分解，并减少循环的复杂性。

内聚性太差的类，某个类大包大揽了许多彼此无关的任务，那么这个类就改拆分成多个类，每个类负责一组具有内在的相互关联的任务。

类的接口未能提供层次一致的抽象，为了维护接口的完整性，程序员常常会在一怒之下对类动手。

拥有太多参数的参数列表，如果一个程序被分解得很好，那么它的子程序应当小巧，定义精确，且不需要庞大的参数列表。

变化导致对多个类的相同修改，只要在程序中加入一种新的输出类型，检查表就会有15个类需要修改。这表明这些类中的代码应当被重新组织，使修改仅影响到其中的一个类。

case语句需要做相同的修改，多个部分修改。

同时使用的相关数据并未以类的方式进行组织，同样一组数据进行操作，也应当问问自己是否将这些数据及操作组织到一个类里面。

成员函数使用其他类的特征比使用自身类的特征还要多，这一子程序应当被放到另一个类中，然后在原来的类里调用。

过多使用基本数据类型，基本数据类可用于表示真实世界中实体的任意数量。简单数据类型，编译器可以对变量执行类型检查。

某个类无所事事，代码的重构会导致某个已有的类无事可做。

一系列传递流浪数据的子程序，把数据传递给某个子程序，是否仅仅就为了让该子程序把数据转交给另一个子程序。是否这些子程序接口的抽象概念相同。

中间人对象无事可做，某个类中的绝大部分代码只是去调用其他类中的成员函数，考虑是否把这样的中间人去掉，转而直接调用其他的类。

某个类同其它类关系过于亲密，最大限度地减少更改代码对周围的连带影响，那么封装可能是最强有力的工具了。

子程序命名不恰当，名字取得不好，改变其定义的名字，并对所有调用该子程序的地方做相应的修改，然后重新编译。

数据成员被设置为公用，把数据成员设置为公用绝对是一个槽糕的主意。这样会模糊接口和实现之间的界限，其本身也违背了封装的原则。

某个派生类仅使用基类的很少一部分成员函数，派生类的创建仅仅是由于基类碰巧有了该类所需要的子程序，而不是出于逻辑上的派生关系。is-a转变为has-a。

注释被用于解释难懂的代码，注释在程序中扮演了重要的角色，但它不应该被用来为拙劣的代码的存在而辩护。

使用了全局变量，访问器子程序来调用这些数据。

在子程序调用前使用了设置代码，调用后使用了收尾代码。

程序中的一些代码似乎是在将来的某个时候才会用到的。超前设计常常会遭遇很多可预见的问题。超前设计的代码是画蛇添足，增加了程序的复杂性，带来了额外的测试，修补缺陷等工作量。

1、需求不可能定义得很完备，这就意味着程序员对未来需求的猜测很可能是错误的。

2、广泛预见未来需求的所有复杂脉络，这些错误复杂的关系将会埋葬程序员的基本设计构思。

3、耗费了大量事件来让这些所谓的超前设计的代码工作起来，到最后却发现这些代码根本没什么用。

## 特定的重构




