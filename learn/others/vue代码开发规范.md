# 基于模块开发

始终基于模块的方式来构建你的app，每一个子模块只做一件事情。Vue.js的设计初衷就是帮助开发者更好的开发界面模块，一个模块是应用程序中独立的一个部分。

# 怎么做

每一个Vue组件首先必须专注于解决一个单一的问题，独立的，可复用的，微小的和可测试的。

你的组件做了太多的事会变得臃肿，请将其拆分为更小的组件并保持单一的原则，一般来说，尽量保证每一个文件的代码行数不要超过100行。

也要保证组件可独立的运行，比较好的做法是增加一个单独的demo示例。

# Vue组件命名

组件命名遵循以下原则：有意义的，简短的，具有可读性的。

同时还需注意：必须符合自定义元素规范(使用连字符分隔单词，切勿使用保留字)；app-前缀作为命名空间，如果非常通用的话可使用一个单词来命名，这样可以方便其它项目里复用。

原因：组件是通过组件名来调用的，所以组件名必须简短，富有含义并且具有可读性。

# 组件表达式简单化

Vue.js的表达式是100%的JS表达式，使其功能性很强大，但也带来潜在的复杂性。应该尽量保持表达式的简单化。

原因：复杂的行内表达式难以阅读；行内表达式是不能够通用的，这可能会导致重复编码的问题；IDE基本上不能识别行内表达式语法，不提供自动补全和语法校验功能。

How：太多复杂并难以阅读的行内表达式，可以使用method或computed属性来替代其功能。

# 组件props原子化

虽然Vuejs支持传递复杂的JS对象使用props属性，但是你应该尽可能地使用原始类型的数据，属性值使用JS原始类型和函数，尽量避免复杂的对象。

why：组件API清晰直观；只使用原始类型和函数作为props使得组件的API更接近于HTML5原生元素；开发者更好理解每一个prop的含义，作用；传递过于复杂的对象使得用户不清楚哪些属性或方法被自定义组件使用，使得代码难以重构和维护。

how：组件的每一个属性单独使用一个props，并且使用函数或是原始类型的值。

# 验证组件的props

在Vue.js中，组件的props即API，一个稳定并可预测的API会使得你的组件更容易被其它开发者使用。

why：验证组件props可以保证你的组件永远是可用的，防御性编程。即使其它开发者并未按照你预先的方法使用时也不会出错。

how：提供默认值；使用type属性校验类型；使用props之前先检查该prop是否存在。

# 组件结构化

按照一定的结构组织，使得组件便于理解。

why：导出一个清晰，组织有序的组件，使得代码便于阅读和理解，同时也便于标准化；按首字母排序properties、data、computed、watches和methods使得这些对象内的属性便于查找；合理组织，便于组件易于阅读(name,extends,props,data和computed,components,watch&&methods,lifecycle methods等)；是一套name实现，便于借助vue devtools可以让你更方便的测试；合理的CSS结构；使用单文件.vue文件格式来组织代码。

how：组件结构化。

## 组件事件命名

Vuejs提供的处理函数和表达式都是绑定在ViewModel上的，组件的每一个事件都应该按照一个好的命名规范来，这样可以避免不少开发问题。

why：

开发者可以随意给事件命名，即使是原生事件的名字，这样会带来迷惑性。

过于宽松的事件命名可能与DOM模板不兼容。

how：

事件名也使用连字符命名

一个事件的名字对应组件内的一组意义操作。eg：upload-success、upload-error以及dropzone-upload-success、dropzone-upload-error。

事件命名应该以动词或是名词结尾。


## 避免this.$parent

Vue支持组件嵌套，并且子组件可以访问父组件的上下文，访问组件之外的上下文违反了基于模块开发的第一原则。

why:

组件必须相互保持独立，Vue组件也是。如果组件需要访问其父层的上下文就违反了该原则。

如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下中复用。

how:

通过props将值传递给子组件

通过props传递回调函数给子组件来达到调用父组件方法的目的

通过在子组件触发事件来通知父组件

## 谨慎使用this.$refs

Vue支持通过ref属性来访问其它组件和HTML元素。并通过this.$refs可以得到组件或HTML元素的上下文。在大多数情况下，通过this.$refs来访问其它组件的上下文是可以避免的，使用的时候你需要避免调用不恰当的组件API，所以应该尽量避免使用this.$refs。

why：

组件必须保持独立，如果一个组件的API不能够提供所需的功能，那么这个组件在设计、实现上是有问题的。

组件的属性和事件必须足够给大多数的组件使用。

how：

提供良好的组件API。

总是关注于组件本身的目的。

拒绝定制代码。如果你在一个通用的组件内部编写特定需求的代码，那么代表这个组件的API不够通用，或者你可能需要一个新的组件来应对该需求。

检查所有props是否确实需要的的，如果有提一个issue或是完善这个组件。

检查所有的事件，子组件向父组件通信一般是通过事件来完成的，但是大多数的开发者更多的关注于props从而忽视了这点。

Props向下传递，事件向上传递，以此为目标升级你的组件，提供良好的API和独立性。

当遇到props或events难以实现的功能时，通过this.$refs来实现。

当需要操作DOM无法通过指令来做的时候可使用this.$ref而不是JQuery，document.getElement*、document.queryElement。

## 使用组件名作为样式作用域空间

vue的组件是自定义元素，这非常适合用来作为样式的根作用域空间。可以将组件名作为css类的命名空间。

why：

给样式加上作用域空间可以避免组件样式影响外部的样式

保持模块名，目录名，样式跟作用域名一样，可以很好的将其关联起来，便于开发者理解。

how：

使用组件名作为样式命名的前缀，可基于BEM或OOCSS范式。同时给style标签加上scoped属性，加上scoped属性编译后会给组件的class自动加上唯一的前缀从而避免样式的冲突。

## 提供组件的API文档

使用Vue组件的过程会创建Vue组件实例，这个实例是通过自定义属性配置的，为了便于其它开发者使用该组件，对于这些自定义属性即组件API应该在README.md文件中进行说明。

why：

良好的文档可以让开发者比较容易的对组件有一个良好的认识，而不用去阅读组件的源码，也更方便开发者使用。

组件配置属性即组件的API，对于组件的用户来说他们更感兴趣的是API而不是实现原理。

正式的文档会告诉开发者组件API变更以及向后的兼容性情况。

README.md是标准的我们应该首先阅读的文档文件。

how：

在模块目录中添加README.md文件。

## 提供组件demo

添加index.html文件作为组件的demo示例，并提供不同配置情况的效果。说明组件是如何使用的。

why:

demo可以说明组件是独立可使用的。

demo让开发者预览组件的功能效果。

demo可以展示组件各种配置参数下的功能。

## 对组件文件进行代码校验

代码校验可以保持代码的统一性以及追踪语法错误，.vue文件可以通过使用eslint-plugin-html插件来校验代码。你可以通过vue-cli来开始你的项目，vue-cli默认会开启代码校验功能。

why：

保证所有的开发者使用同样的编码规范。

更早的感知到语法错误。

how：

使用静态代码分析工具。eslint。

## 只在需要时创建组件

why：

vue是一个基于组件的框架，如果你不知道何时创建组件可能会导致以下问题

如果组件太大，可能很难重用和维护。

如果组件太小，你的项目就会因为深层次的嵌套被淹没，也更难使组件间通信。

how：

始终记住你的项目需求构建你的组件，但是你也应该尝试想到它们能够从中脱颖而出。如果它们能够在你项目之外工作，就像一个库那样，那就使得它们更加健壮和一致。

尽可能早地构建你的组件总是更好的，因为这样使得你可以在一个已经存在和稳定的组件上构建你的组件通信。

规则：

尽可能早的尝试构建出注入模态框、提示框、工具条、菜单、头部等这些明显的通用型组件。

每个新开发的项目中，对于一整个页面或其中的一部分，在进行开发前先尝试思考一下，如果你认为它有一部分应该是一个组件，那么就创建它。

不确定，那就不要，避免那些以后可能会有用的组件污染你的项目。一旦你意识到应该这么做，最好是就把它打破，以避免与项目的其它部分构成兼容性和复杂性。

## 尽可能使用mixins

why：

Mixins封装可重用的代码，避免了重复。如果两个组件共享有相同的功能，则可以使用mixin。通过mixin，你可以专注于单个组件的任务和抽象的通用代码。这有助于更好地维护你的应用程序。

how：

mixins:[]


eslint添加规则。

