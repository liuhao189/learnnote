# 重构

神话：一个管理很完善的软件项目，应该首先以系统化的方法进行需求开发，定义一份严谨的列表来描述程序的功能。设计完全遵循需求，并且完成得相当仔细，这样就让程序员的代码编写工作能够从头至尾直线型地工作。测试通过后即可被抛到脑后，代码被修改的唯一时机就是在软件维护阶段。

现实情况：在初始开发阶段，代码会有实质性的进化。在初始的代码编写过程中，就会出现很多剧烈的改变。即使是管理完善的项目，每个月都有大约25%的需求发生变化，需求的变化将不可避免地导致相关代码的改变-有时是实质性的代码改变。

另一个事实：现在的开发方法增强了代码在构造阶段中改变的潜力，在旧式的软件生命周期中，项目成果与否的关键在于能否避免代码的改变。

# 软件演化的类型

软件演化就像生物进化一样，有些突变对物种是有益的，另外一些则是有害的。良性的软件演化使代码得到了发展，有时演化的力量也会以另一种方式打击你的程序。

区分软件演化类型的关键，就是程序的质量在这一过程中是提高了还是降低了。

第二个标准，就是这样的演化是源于程序构建过程中的修改，还是维护过程中的修改。前者通常由最初的开发人员完成，处于高度动态阶段，出现错误的代价较小。

## 软件演化的哲学

程序员在参与到软件演化时有一个普遍的弱点，这就是将其作为一种并非有意而为的过程。在开发过程中认识到软件演化是无法避免且具有重要意义的现象，并对其细加谋划，就可能使这一过程有益于你的开发。

演化使你的软件开发接近完美的天赐良机，当你迫不得已需要对代码进行改变时，就努力对代码进行改进，这样未来在开发中调整就会更容易。

软件演化的基本准则就是，演化应当提升程序的内在质量。

# 重构简介

要实现软件演化基本准则，最关键的策略就是重构，其定义为在不改变软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改。

## 重构的理由

有时，代码在维护过程中质量会降低，而有时代码在最初诞生的时候就先天不良。

代码重复，重复的代码几乎总是代表着对最初设计里彻底分解方面的一个失误。重复代码违背了DRY（Do not repeat yourself）原则，复制粘贴即设计之谬。

冗长的子程序，很少需要用到长度超过一个屏幕的子程序。改善系统的方法之一就是提升其模块性，增加定义完善、命名准确的子程序，让它们各自集中力量做好一件事情。

循环过长或嵌套过深，循环内部的复杂代码常常具备转换为子程序的潜质，这样的改动将有助于对代码的分解，并减少循环的复杂性。

内聚性太差的类，某个类大包大揽了许多彼此无关的任务，那么这个类就该拆分成多个类，每个类负责一组具有内在的相互关联的任务。

类的接口未能提供层次一致的抽象，为了维护接口的完整性，程序员常常会在一怒之下对类动手。

拥有太多参数的参数列表，如果一个程序被分解得很好，那么它的子程序应当小巧，定义精确，且不需要庞大的参数列表。

变化导致对多个类的相同修改，只要在程序中加入一种新的输出类型，就会有15个类需要修改。这表明这些类中的代码应当被重新组织，使修改仅影响到其中的一个类。

case语句需要做相同的修改，多个部分修改。

同时使用的相关数据并未以类的方式进行组织，同样一组数据进行操作，也应当问问自己是否将这些数据及操作组织到一个类里面。

成员函数使用其他类的特征比使用自身类的特征还要多，这一子程序应当被放到另一个类中，然后在原来的类里调用。

过多使用基本数据类型，基本数据类可用于表示真实世界中实体的任意数量。简单数据类型，编译器可以对变量执行类型检查。

某个类无所事事，代码的重构会导致某个已有的类无事可做。

一系列传递流浪数据的子程序，把数据传递给某个子程序，是否仅仅就为了让该子程序把数据转交给另一个子程序。是否这些子程序接口的抽象概念相同。

中间人对象无事可做，某个类中的绝大部分代码只是去调用其他类中的成员函数，考虑是否把这样的中间人去掉，转而直接调用其他的类。

某个类同其它类关系过于亲密，最大限度地减少更改代码对周围的连带影响，那么封装可能是最强有力的工具了。

子程序命名不恰当，名字取得不好，改变其定义的名字，并对所有调用该子程序的地方做相应的修改，然后重新编译。

数据成员被设置为公用，把数据成员设置为公用绝对是一个槽糕的主意。这样会模糊接口和实现之间的界限，其本身也违背了封装的原则。

某个派生类仅使用基类的很少一部分成员函数，派生类的创建仅仅是由于基类碰巧有了该类所需要的子程序，而不是出于逻辑上的派生关系。is-a转变为has-a。

注释被用于解释难懂的代码，注释在程序中扮演了重要的角色，但它不应该被用来为拙劣的代码的存在而辩护。

使用了全局变量，访问器子程序来调用这些数据。

在子程序调用前使用了设置代码，调用后使用了收尾代码。

程序中的一些代码似乎是在将来的某个时候才会用到的。超前设计常常会遭遇很多可预见的问题。超前设计的代码是画蛇添足，增加了程序的复杂性，带来了额外的测试，修补缺陷等工作量。

1、需求不可能定义得很完备，这就意味着程序员对未来需求的猜测很可能是错误的。

2、广泛预见未来需求的所有复杂脉络，这些错综复杂的关系将会埋葬程序员的基本设计构思。

3、耗费了大量事件来让这些所谓的超前设计的代码工作起来，到最后却发现这些代码根本没什么用。

## 特定的重构

### 数据级的重构

以下的重构方法可用于改进变量和其它数据类型的使用。

用具名常量替代神秘数值，使用了数字或字符串表示形式，请将这样的字符使用具名常量替代。

使变量的名字更为清晰且传递更多信息，如果一个变量的名字容易让人对其产生误解，就换个好点的名字。

将表达式内联化，把一个中间变量换成给它赋值的那个表达式本身。

用函数来代替表达式，用一个函数来代替表达式。

引入中间变量，表达式的值赋给中间变量，命名应能准确概况表达式的用途。

用多个单一用途变量代替某多用途变量，多个变量来让它们各司其职吧。

在局部用途中使用局部变量而不是参数，直接创建局部变量来代替参数。

将基础数据类型转换为类，一个基础数据类型需要额外的功能或额外的数据，把该数据转换为一个对象，然后再添加你所需要的类行为。

将一组类型码转换为类或枚举类型，享受严格类型检查所带来的好处。

将一组类型码转换为一个基类加相应派生类，不同类型相关联不同代码片段。

将数组转换为对象，不同元素具有不同的类型，应该用一个对象来替代它，将数组中的各个元素转化为该类的各个成员。

把群组封装起来，把你的类返回一个只读群集，并且提供相应的添加和删除元素的子程序。

用数据类来代替传统记录，建立一个包含记录成员的类，集中完成对记录的错误检查，持久化和其它与该记录相关的操作。

## 语句级的重构

改善单个语句的使用。

分解布尔表达式，引入命名准确的中间变量来简化复杂的布尔表达式，通过变量名更好地说明表达式的含义。

将复杂布尔表达式转换成命名准确的布尔函数，表达式过于复杂，这项重构可以提高可读性。

合并条件语句不同部分中的重复代码片段，完全相同的代码同时出现在一个条件语句的if语句块和else语句块中。

使用break或return而不是循环控制变量。eg：isDone

在嵌套if-then-else语句中一旦知道答案就立即返回，而不是去赋一个返回值。eg：最后一句return result。

用多态来替代条件语句，尤其是重复的case语句，结构化程序里很多的case语句中的逻辑都可以被放到继承关系中，通过多态函数调用实现。

创建和使用null对象而不是去检测空值。eg：NullPerson。

## 子程序级重构

提取子程序或方法，内嵌的代码从一个子程序中提取出来，并将其提炼为单独的子程序。

将子程序的代码内联化，如果子程序的程序体很简单，且含义不言自明，在使用的时候直接使用这些代码。

将冗长的子程序转换为类，子程序太长，可以将其转换为类，然后进一步分解，得到的多个子程序来改善该代码的可读性。

用简单算法替代复杂算法，更为简单的算法来替代复杂的算法。即使性能会有一定的下降。

增加参数，需要从调用方获取更多的信息，可以增加它的参数从而为其提供信息。

删除参数，子程序已经不再使用某个参数，就删除它。信息封装和隐藏。

将查询操作从修改操作中独立出来，查询操作并不改变对象的状态。

合并相似的子程序，通过参数区分它们的功能，相似子程序的唯一区别或许只是其中用到的常量值不同，请把它们合并到一起。eg：search(type)。

将行为取决于参数的子程序拆分开来，一个子程序根据输入参数的值执行了不同的代码，考虑将它们拆分成几个可被单独调用的，无须传递特定参数的子程序。eg：复杂一些。

传递整个对象而非特定成员，一个对象的多个值被传递给了一个子程序，考虑是否可修改其接口使之接收整个对象。eg：函数签名简单。

传递特定成员而非整个对象，创建对象的唯一理由只是你需要将它传入某个子程序，可以考虑修改一下这个子程序，使之接收特定数据成员而非整个对象。eg：看成员数量。

包装向下转型的操作，子程序返回一个对象时，应当返回其已知的最精确的对象类型。

## 类实现的重构

将值对象转化为引用对象，自己创建并维护着多份一模一样的大型复杂对象，请改变对这些对象的使用方式。

将引用对象转换为值对象，某个小型的简单对象进行了多次引用操作，将这些对象设置为值对象。

用数据初始化替代虚函数，一组派生类，差别仅仅是虚函数返回的常量不同，不如在派生类初始化时设定适当的常量值。

改变成员函数或成员数据的位置，考虑对类的继承体系做出修改，这些修改通常可以减少派生类的重复工作。

1、将子程序上移到基类中

2、将成员上移到基类中

3、将构造函数中的部分代码上移到基类中

对派生类进行特殊化：

1、将子程序下移到派生类中

2、将成员下移派生类中

3、将构造函数下移到派生类中。

将特殊代码提取为派生类，类里的一部分代码仅仅被其部分实例所使用，应该把这部分特殊的代码放到其派生类中。

将相似的代码结合起来放置到基类中，两个派生类有相似的代码，将这些代码结合起来并放到基类中。

# 类接口的重构

将成员函数放到另一个类中。

将一个类变成两个，如果一个类同时具备了两种或更多的截然不同的功能，请把这样的类转化为多个类，使得每个类完成一种明确定义的功能。

删除类，某个类无所事事，就应该把该类的代码放到与所完成功能关系更为密切的另一个类中，然后把这个类删掉。

去除委托关系，考虑类的接口抽象是否合适。

去掉中间人，考虑类的接口抽象是否合适。

用委托代替继承，某类需要用到另一个类，has-a，公开它的一组成员函数，以完成一种内聚的抽象。

用继承代替委托，某个类公开了委托类所有的成员函数，应该继承，而不是委托。

引入外部的成员函数，新成员函数的方式来提供此功能。

引入扩展类，需要多个额外的成员函数，同样无法修改该类，可以创建一个新类。包含原类的功能以及新增加的功能。

对暴露在外的成员变量进行封装，成员函数来访问该数据成员的值。

对于不能修改的类成员，删除相关的Set成员函数。构造函数中对该成员初始化，而不是使用可能产生误导的set成员函数。

隐藏那些不会再类之外被用到的成员函数。

封装不使用的成员函数，自己往往只使用类接口的一部分，那么就为类创建新的接口。类的接口应该为类提供一致的抽象。

合并那些实现非常类似的基类和派生类。

## 系统级重构

这里的重构方法可以在整个系统一级改善代码。

为无法控制的数据创建明确的索引源，需要让特定系统类维护数据。eg：GUI控件和其它代码将此类作为该数据的明确来源。

将单向的类联系改为双向的类联系，各自需要用到对方的功能，对两个类进行修改，使其能互相调用。

将双向的类联系改为单向的类联系，只让那个有实际需要的类能访问另一个类

用Factory Method模式而不是简单地构造函数，需要基于类型码创建对象或者希望使用引用对象而非值对象的时候，应当使用Factory Method函数。

用异常取代错误处理代码，或者做相反方向的变换，取决于你的错误处理策略。

# 安全的重构

重构是一种改善代码质量的强有力的技术，但同时伴随着风险。

保存初始代码，在开始重构之前，要保证你还能回到代码的初始状态。

重构步伐请小些。

同一时间只做一项重构，有的重构会比其它的重构更为复杂。进入下一项重构之前，对代码重写编译并测试。

把要做的事情一条条列出来，伪代码编程过程的自然延伸就是列出一份重构列表。

设置一个停车场，把你需要在未来某个时间进行而现在可以先放在一边的修改工作列出来。

多使用检查点，多个存档点。

利用编译器警告信息，最好把编译器的警告级别设置为尽肯能苛刻。

重新测试，把重新测试作为检查所修改代码工作的补充。

增加测试用例，除了重新运行过去做过的那些测试，还应该增加新的单元测试来检测新引入的代码。

检查对代码的修改，程序员对于很小的修改常常不以为然，不会用纸和笔来推敲程序，也不会让其它人来检查代码。甚至不会运行这些代码来验证修改工作的正确性。

根据重构风险级别来调整重构方法，设计到类，成员函数接口，数据库构架等改变，或是对布尔判断等进行修改的重构则极具风险。

## 不宜重构的情况

重构也有被滥用的可能性。

不要把重构当做先写后改的代名词，最大的问题在于被滥用。不是无法运行的代码进行修修补补。

避免用重构代替重写，大规模重构之中，就应该问问自己是否应该把这部分代码推倒重来，重新设计，重新开发。






