# 子程序中的多处返回

程序可以通过return和exit这类控制结构，在任何需要的时候退出子程序。它导致子程序按照正常的退出途径终止，并把控制权转交给调用方子程序。

如果能增强可读性，那么就使用return。一旦知道了答案，你会希望马上返回调用方子程序。

用防卫子句早返回或早退出来简化复杂的错误处理。代码中必须要在执行正常操作之前做大量的错误条件检测，就很可能导致代码缩进层次过深，并且遮蔽了正常情况的执行路径。

减少每个子程序中的return的数量。

# 递归

递归，一个子程序自己负责解决某个问题的一小部分，它还把问题分解成很多的小块，然后调用自己来分别解决每一小块。

确认递归能够停止，检查子程序其中含有一条非递归的路径，通常这意味着该子程序中含有一项判断，无须进一步递归就能停下来。

使用安全计数器防止出现无穷递归，安全计数器必须是一个不随每次子程序调用而重写创建的变量。

把递归限制在一个子程序内，理解跨越多个子程序的递归实在勉为其难。

留心栈空间，应该给递归子程序分配多少栈空间；应注意观察递归函数中局部变量的分配情况，特别留意那些内存消耗大的对象。

不要用递归去计算阶乘或斐波那契数列。

用递归之前你应该考利它的替换方案。用递归能做到的，同样也可以用栈和循环来做到。

# goto

反对goto的论点，没有使用goto的代码就是高质量的代码。含有goto的代码很难安排好格式，破坏编译器的优化特性。有些优化要求程序的控制流程位于不多的几个语句之间，无条件的goto确使得流程变得很难分析。从而削弱了编译器优化代码的能力。使用goto会违背代码应该严格自上而下的原则。

支持goto的观点，强调在特定的场合下谨慎地使用goto。如果位置恰当，goto可以减少重复的代码。

# 要点

多个return子句可以增强子程序的可读性和可维护性，同时可以避免产生很深的逻辑嵌套。但是使用它的时候要多加小心。

递归能够很优雅地解决一小部分问题，对它的使用也要倍加小心。

在少数情况下，goto是编写可读性和可维护性代码的最佳方法，但是这种情况非常罕见，除非万不得已，不要使用goto。

