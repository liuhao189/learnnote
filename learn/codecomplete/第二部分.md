<font size="4px">
# 软件构建中的设计

## 设计中的挑战

软件设计意味着去构思，创造或发明一套方案，把一份计算机软件的规格说明书要求转变为可实际运行的软件。

设计就是把需求分析和编码调试连在一起的活动，好的高层设计能提供一个可以稳妥容纳多个较低层次设计的结构。

### 设计是一个险恶的问题

险恶的问题就是那种只有通过解决或部分解决才能被明确的问题。必须首先把这个问题解决一遍以便能够明确地定义它，然后再次解决该问题，从而形成一个可行的方案。

### 设计是个了无章法的过程

软件设计的成果应该是组织良好，干净利落的，然而形成这个设计的过程却并非如此清爽。

犯错正是设计的关键所在，在设计阶段犯错并加以改正，其代价要比在编码后才发现同样的错误并彻底修改低得多。

优劣设计之间的差异往往非常微妙。

### 设计就是确定取舍和调整顺序的过程

设计者的一个关键内容便是去衡量彼此冲突的各项设计特性，并尽力在其中寻求平衡。

### 设计受到诸多限制

设计的要点，一部分是在创造可能发生的事情，而另一部分又是在限制可能发生的事情。

### 设计是不确定性的

三个人设计一套同样的程序，很可能会做出三套截然不同的设计，而每套设计都很不错。

### 设计是一个启发式的过程

正因为设计过程充满了不确定性，因此设计技术也就趋于具有探索性，经验法则。

### 设计是自然而然形成的

设计是在不断的设计评估，非正式讨论，写试验代码以及修改试验代码中演化和完善的。

# 关键的设计概念

## 软件的首要技术使命：管理复杂度

### 偶然的难题和本质的难题

两类不同的问题导致软件开发变得困难：本质的问题和偶然的问题。

在哲学界，本质的属性是一件事物必须具备，如果不具备就不再是该事物的属性。偶然的属性则是指一件事物碰巧具有的属性，有没有这些属性都并不影响这件事物本身。

偶然性难题在很久以前就已经得到解决了。在软件开发剩下的那些本质性苦难上的进展将会变得相对缓慢。

本质上说软件开发就是不断地去发掘错综复杂，相互连接的整套概念的所有细节。当软件要解决更大规模的现实问题时，现实的实体之间的交互行为就变得更为复杂。转而又增加软件解决方案的本质性困难。

### 管理复杂度的重要性

导致软件项目失败的原因，很少把技术原因归为项目失败的首要因素，项目的失败大多数都是由差强人意的需求，规划和管理所导致的。

当项目确由技术因素导致失败时，其原因通常就是失控的复杂度。有关的软件变得极端复杂。

管理复杂度是软件开发中最为重要的技术话题，软件的首要技术使命便是管理复杂度，它是在是太重要了。

没有谁的大脑能容得下一个现代的计算机程序，作为软件开发人员，我们不应该试着去同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分。

软件架构的层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。所有软件设计技术的目标都是把复杂问题分解成简单的部分。子系统间的相互依赖越少，你就越容易在同一时间里专注问题的一小部分。精心设计的对象关系使关注点相互分离，从而使你能在每个时刻只专注于一件事情。

保持子程序的短小精悍也能帮助你减少思考的负担。从问题的领域着手，而不是从底层实现细节入手去编写程序，在最抽象的层次上工作，也能减少人的脑力负担。

### 如何应对复杂度

高代价，低效率的设计源于下面三种根源：用复杂的方法解决简单的问题；用简单但错误的方法解决复杂的问题；用不恰当的复杂方法解决复杂的问题。

用下面的这两种方法来管理复杂度：

把任何人在同一时间需要处理的本质复杂度的量减到最少；不要让偶然性的复杂度无谓地快速增长。

## 理想的设计特征

高质量的设计具有很多常见的特征，一系列相互竞争的目标之中作出一套最好的折中方法。

### 最小的复杂度

设计的首要目标就是让复杂度最小，避免做出聪明的设计，因为聪明的设计常常都是难以理解的。应该作出简单且易于理解的设计。

### 易于维护

易于维护意味着在设计时为做维护工作的程序员着想。设计出能自明的系统。

### 松散耦合

松散耦合意味着在设计时让程序的各个组成部分之间关联最小。通过应用类接口中的合理抽象，封装性及信息隐藏等原则，设计出相互关联尽可能少的类。

### 可扩展性

可扩展性是说你能增强系统的功能而无需破坏其底层结构。可以改动系统的某一部分而不会影响到其它部分。

### 可重用性

设计的系统的组成部分能在其它系统中重复使用。

### 高扇入

让大量的类使用某个给定的类，意味着设计出的系统很好地利用了在较低层次上的工具类。

### 低扇出

让一个类里少量或适中地使用其它的类，高扇出说明一个类使用了大量其它的类，变得过于复杂。

### 可移植性

可移植性是说应该这样设计系统，使它能很方便地移植到其它环境中。

### 精简性

精简性意味着设计出的系统没有多余的部分。一本书的完成，不在于它不能再加入任何内容的时候，而在于不能再删去任何内容的时候。

### 层次性

层次性意味着尽量保持系统各个分解层的层次性，使你能在任意的层面上观察系统，并得到某种具有一致性的看法。

### 标准技术

一个系统所依赖的外来的，古怪的东西越多，别人在第一次想要理解它的时候就越是头疼。要尽量用标准化的，常用的方法，让整个系统给人一种熟悉的感觉。

## 设计的层次

需要在一个软件系统中的若干不同细节层次上进行设计。有些设计技术适用于所有的层次，而有些只适用于某些层次上。

### 软件系统

第一个层次就是整个系统，有的程序员直接从系统层次就开始设计类，但是往往先从子系统或包这些类的更高组织层次来思考会更有益处。

### 分解为子系统或包

在这一层次上设计的主要成果是识别出所有的主要子系统，这些子系统可能会很大，比如说数据库，用户界面，业务规则，命令解释器，报表引擎等。这一层的主要设计活动就是确定如何把程序分为主要的子系统，并定义清楚允许各子系统如何使用其它子系统。

不同子系统之间相互通信的规则，如果所有的子系统都能同其它子系统通信，你就失去了把它们分开所带来的好处，应该通过限制子系统之间的通信来让每个子系统更有存在意义。

为了让子系统之间的连接简单易懂且易于维护，就要尽量简化子系统之间的交互关系。系统层次设计图应该是无环图。

## 第二层常用的子系统

### 业务规则

业务规则是指那些在计算机系统中编入的法律，规则，政策以及过程。

### 用户界面

应创建一个子系统，把用户界面组件同其它部分分隔开，以便使用户界面的演化不会破坏程序的其余部分。

### 数据库访问

把对数据库进行访问的实现细节隐藏起来，让程序的绝大部分可以不必关心处理底层结构的繁琐细节，并能像在业务层次一样处理数据。

隐藏实现细节的子系统可以为系统提供有价值的抽象层，从而减少程序的复杂度。

### 对系统的依赖性

把对操作系统的依赖因素归到一个子系统里，就如同把对硬件的依赖因素封装起来一样。

## 第三层分解为类

在这一层次上的设计包括识别出系统中所有的类。把所有的子系统进行适当的分解，并确保分解出的细节都恰到好处，能够用单个的类实现。

类和对象的比较：对象是指运行期间在程序中实际存在的具体实体，对象是动态的，拥有你在程序运行期间所能得到的具体的值和属性；而类是指在程序源码中存在的静态事物。

## 第四层分解成子程序

这一层的设计包括把每个类细分为子程序。细化出类的私用子程序。完整地定义出类内部的子程序，常常会有助于更好地理解类的接口。

留给程序员个人来完成的。

## 第五层子程序内部的设计

在子程序层次上进行就是为每个子程序布置详细的功能。子程序内部的设计工作通常是由负责该子程序的开发人员来完成的。

编写伪代码，选择算法，组织子程序内部的代码块，以及用编程语言编写代码。

# 设计构造块：启发式方法

对于具体的编程工作来说，期待确定性的行为是很正常的，无论这种对细节的关注会给程序带来好处还是坏处。

由于软件设计师非确定性的，灵活熟练地运用一组有效的启发式方法，便成了合理的软件设计的核心工作。

## 找出现实世界中的对象

确定设计方案时，首选且最流行的一种做法便是常规的面向对象设计方法，此方法的要点是辨识显示世界中的对象以及人造的对象。

辨识对象及其属性，确定可以对各个对象进行的操作，确定各个对象能对其它对象进行的操作，确定对象的可见性，定义每个对象的公开接口。

### 辨识对象及其属性

计算机程序通常都是基于现实世界的实体。深入挖掘问题领域可能会得出更好的设计方案。

### 定义可对对象执行的操作

每个对象上都可以执行多种操作。

### 确定每个对象对其它对象进行的操作

对象之间最常见的两者关系是包含和继承，哪些对象可以包含其它对象，哪些对象又可以从其它对象继承。

### 确定对象的哪些部分对其它对象可见

一项关键的设计决策就是明确对象的哪些部分应该是公开的，哪些部分又应该是不公开的，对数据和方法都要做这一决策。

### 定义每个对象的接口

在编程语言的层次上为每个对象定义具有正式语法的接口。公开的接口和受保护的接口。

经过上面这些步骤得到了一个高层次的，面向对象的系统组织结构之后，可以在高层次的系统组织结构上进行迭代，以便更好地组织类的结构；或者在每一个定义好的类上进行迭代，把每个类的设计细化。

### 形成一致的抽象

抽象是一种能让你在关注某一概念的同时可以放心地忽略其中一些细节的能力，在不同的层次处理不同的细节。

任何时候当你在堆一个聚合物品工作时，你就在使用抽象了。

基类也是一种抽象，它使得你能集中精力关注一组派生类所具有的共同特性，并在基类的层次上忽略各个具体派生类的细节。

一个好的接口也是一种抽象，它能让你关注与接口本身而不是类的内部工作方式。

以复杂度的观点看，抽象的主要好处就在于它使你能忽略无关的细节。

### 封装实现细节

封装填补了抽象留下的空白，抽象是说，可以让你从高层的细节来看待一个对象。而封装则说，除此之外，你不能看到对象的任何其它细节层次。

### 继承能简化设计时就继承

定义这种对象之间的相同点和不同点就叫继承。继承的好处在于它能很好地辅佐抽象的概念。继承能简化编程的工作，因为你可以写一个基本的子程序来处理只依赖于门的基本属性的事项。

运行期间才能确定所针对的对象的实际类型的操作，这种能力叫做多态。继承是面向对象编程中最强大的工具之一。

### 隐藏秘密信息隐藏

信息隐藏是结构化程序设计与面向对象设计的基础之一。结构化设计里面的黑盒子概念就是源于信息隐藏，在面向对象设计中，它又能引出了封装和模块化的概念，并与抽象的概念紧密相关。

信息隐藏是软件的首要技术使命中格外重要的一种启发式方法，因为它强调的就是隐藏复杂度。

秘密和隐私权：当信息被隐藏后，每个类都代表了某种对其它类保密的设计或构建决策。隐藏起来的可能是某个易变的区域，或者某种文件格式，或某种数据类型的实现方式，或某个需要隔离的区域。类的职责是把这部分信息隐藏起来，并保护自己的隐私权。

设计一个类的时候，一项关键性的决策就是确定类的哪些特性应该对外可见，而哪些特性应该隐藏起来。

### 两种秘密

信息隐藏中所说的秘密主要分为两大类：

隐藏复杂度：这样你就不用再去应付它，除非你要特别关注的时候

隐藏变化源：这样当变化发生时，其影响就能被限制在局部范围内。

### 信息隐藏的障碍

信息隐藏是根本不可能的，惯用某些技术而导致的心理障碍。

信息过渡分散，信息在系统中过度分散。eg：魔法字符串，人际交互子系统。

循环依赖，无法单独测试。

把类内数据误认为全局数据，并避免使用它，全局变量会让你陷入很多编程陷阱。

子程序在全局数据之上执行操作，不知道其它子程序也在用这些全局数据进行操作。

子程序无法明确地知道其它子程序都进行了哪些操作。

可以察觉的性能损耗：视图在系统架构层和编码层均避免性能上的损耗。编码层为性能目标所做的最好的准备，便是作出高度模块化的设计来，等你日后找出性能的瓶颈，针对个别的类或者函数进行优化而不会影响系统的剩余部分了。

### 信息隐藏的价值

信息隐藏有着独特的启发力，它能够激发出有效的设计方案。

信息隐藏同样有助于设计类的公开接口。eg：等同于找出使用最方便的那个接口，这通常就导致类内部过多的内容被暴露出来。

在设计的所有层面上，都可以通过询问该隐藏什么来促成好的设计决策。

## 找出容易改变区域

