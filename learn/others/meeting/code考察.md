# code考察

能面试到这里的，面试官其实假设你是刷过不少题目的，我假设你刷过这个题目，所以我并不关心你写的到底有多快，写得是不是完全bug free。我更关心的是你的做事方式和沟通问题的能力。

1、提出问题，请序列化/反序列化二叉树。

不知道什么是序列化，反序列化？那问个多线程爬虫，timing LRU一类的。如果多线程，锁也不会，那说明这个面试者的项目经验很不足。为了和其它有经验的人相match，往往我会给一个很open的问题，或者一个很难的hard coding(取决他已经被考察哪个方面)。当面试者与其它人相比显得缺少项目经验，它除非能在聪明敏捷或下苦功夫方面有突出表现，否则很难击败其它候选人。

2、交流阶段

如果面试者马上开始写程序，或者马上给出他的想法，我会觉得面试者太过于着急了。你总是需要有很好的沟通能力，确保大家知道你在做什么，及早发现你的错误。

期望面试者这个阶段提出一些问题，有什么限制条件吗？二叉树的value是什么类型，这个api谁来使用，内部的还是public的？这个api更注重speed还是space，需要多线程吗？如果面试者做事的方式不够成熟，可能以后工作中会很毛躁，需要人来指导。

3、避免陷入套路

无论你的提出的意见是什么，例如我觉得speed更重要，我可能会说我更期待space，这样做是避免陷入你最熟悉的套路。

假设我说，我更需要序列化之后的空间占用最小，这时候一般的候选人不会刷到这么深，开始思考。

如果候选人根本没有办法优化空间，那么我会认为他give up too early，我希望候选人能安静的思考，提出几种方案，哪怕方案不成立。

如果候选人提出过多的方案，没有寻求help，这些方案也不工作，我就认为候选人沟通有问题，无法把握好度。

4、候选人选定方案后，我希望他能和我沟通，看看是不是在有限时间内能够写完。项目中，很多时候谁都知道什么design是正确的，什么是bad smell，最聪明的人不是能作出最好design的，而是在有限时间内能给出大家都能接受的solution的人。如果空间优化非常好，代码将超级复杂，无法写完，那么面试者应该及时和我交流。我看他是不是能写完，这就是either strong hire or fail。

5、候选人可能说太复杂了，我们简化一下，简化到他熟悉的，刷过的coding。

6、coding开始，如果你2，3，4，5中的大部分，并且code看起来似乎是work的，没有什么致命的问题，我不会纠结与正负数，代码整洁之类的问题。
如果你不做2，3，4，5，我一般希望你bug free并且code组织很好。

7、follow up，还有什么能改进的吗？考察面试者的知识面，也看你是不是耐心。很多时候面试者作出题目会高兴的得意忘形，到这里开始语无伦次的乱说，这不会影响到是不是hire，但是可能会影响是不是strong hire，也可能影响到你的level。

# code种类

大致上，面试官在开始面试前，会收到一封email，里面会大致说明每个人需要侧重于考察面试者的哪个方面。对于coding来说，一般有三类问题，每个面试官会被分配到一类问题。

1、solid coding，谁都知道怎么做，纯粹是考察coding是不是扎实，平时自己写code多不多，能不能快速的把自己的idea转换为code。对于面试者来说属于必考种类，new grad一般会有两轮甚至三轮这样的题目，有很多工作经验的人可能就只有1轮了，这类题目不过关，很可能电面死掉或者前几轮突然死亡。

solid codeing又一般分成两个小类：

1.1、考察你对算法的基本理解以及边界条件的运用。eg：find kth largest interger, search in rotate array，bit manipulation等

1.2、考察你对基本数据结构以及复杂度的理解。eg：binary search tree，linkedlist vs array，stack，tree dfs，tree bfs等等

## 应对策略

1.1类型，如果是简单和medium的没得说，希望你又快又好，除了勤奋和熟练，没有什么好策略。对于像merge sort，partition这类的算法，如果7-8分钟还写不出bug free我估计就没戏了，easy问题请多多注意边界条件，int溢出，nullpointer，负数，非法输入等。

1.2类型，简单的和medium请在写代码前多阐明复杂度，这类数据结构的问题往往也可以在coding前画图来表示运行状态。图画得清楚也是个重要的加分项

1.3类型，hard类型的coding题目，往往是考察你solid coding的能力，你做事的方式和你思考问题的方法。即给你一个coding任务，你如何从白板开始，一步步的作出bug free的程序。这类问题过程重于结果。你能确保是每实现一个模块，都没有regressgion，都没有bug，比你一下子实现所有的feature但是有很多bug要好很多。一般来说面试官看你是否能够一步步的分隔出小的coding模块，你如何设计test case，如何能够确保这些test case能cover住所有scenario，是不是和面试官做了足够的沟通并且限定了coding范围。


## problem resolving

这类问题对于new grad是关键，也是能帮你和其它人区别开来的关键。计算机并不只有算法，我们还需要数据库，操作系统，网络，安全等方面的知识。

new grad这些方面要弱一些，面试者希望new grad能展现出思维敏捷，多思考，快速反应的能力。

problem resolving也可以分为四个小类型：

1、API design，这类问题是为了更深入的考察你对数据结构的理解和运用。

2、Abstraction，这类问题是考察你能不能把一个相对抽象的问题映射到你熟悉的问题上面。

3、计算机小程序，thread pool，爬虫，日志merge，random generator等

4、dynamic programming问题，这类问题有点像solid problem resolving，主要考察你是不是有systemmatic的方法来降低一个brute force程序的复杂度。

## 应对策略

1、主要考察你对数据结构的深层次认识，首先确保你理解了题目的意思，最好能问清条件，问清这类的问题有助于你写代码前做好重构和测试的准备。如果你能证明你选择的算法的复杂度，甚至证明这就是最佳复杂度，那是一个大大的加分项，如果不能，至少你也问问面试官是不是已经满意了再开始写代码。

2、比较头疼，靠灵光一闪。

3、这类问题主要看你平时的积累，也是一大类不能通过leetcode练习的问题。

4、动态规划，面试中的动态规划大致分为单向递归，距离递归，O(mn)递归，有限定条件的NP(背包)。每种类型听几节课，懂了基本原理即可。至于贪心的带状态的dp，很难临时造出一道这样的题目，面试官一般也没这个能力和时间来思考题目是不是严谨。

## bar raiser

这类问题只有当onsite应聘者的数量远远大于head count的时候，或者你前几轮明显超出了电面时对你的定位才会发生，其目的是帮助公司选择最优秀的人。
