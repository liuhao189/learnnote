# 重构

神话：一个管理很完善的软件项目，应该首先以系统化的方法进行需求开发，定义一份严谨的列表来描述程序的功能。设计完全遵循需求，并且完成得相当仔细，这样就让程序员的代码编写工作能够从头至尾直线型地工作。测试通过后即可被抛到脑后，代码被修改的唯一时机就是在软件维护阶段。

现实情况：在初始开发阶段，代码会有实质性的进化。在初始的代码编写过程中，就会出现很多剧烈的改变。即使是管理完善的项目，每个月都有大约25%的需求发生变化，需求的变化将不可避免地导致相关代码的改变-有时是实质性的代码改变。

另一个事实：现在的开发方法增强了代码在构造阶段中改变的潜力，在旧式的软件生命周期中，项目成果与否的关键在于能否避免代码的改变。

# 软件演化的类型

软件演化就像生物进化一样，有些突变对物种是有益的，另外一些则是有害的。良性的软件演化使代码得到了发展，有时演化的力量也会以另一种方式打击你的程序。

区分软件演化类型的关键，就是程序的质量在这一过程中是提高了还是降低了。

第二个标准，就是这样的演化是源于程序构建过程中的修改，还是维护过程中的修改。前者通常由最初的开发人员完成，处于高度动态阶段，出现错误的代价较小。

## 软件演化的哲学

程序员在参与到软件演化时有一个普遍的弱点，这就是将其作为一种并非有意而为的过程。在开发过程中认识到软件演化是无法避免且具有重要意义的现象，并对其细加谋划，就可能使这一过程有益于你的开发。

演化使你的软件开发接近完美的天赐良机，当你迫不得已需要对代码进行改变时，就努力对代码进行改进，这样未来在开发中调整就会更容易。

软件演化的基本准则就是，演化应当提升程序的内在质量。

# 重构简介

要实现软件演化基本准则，最关键的策略就是重构，其定义为在不改变软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改。

## 重构的理由

有时，代码在维护过程中质量会降低，而有时代码在最初诞生的时候就先天不良。

代码重复，重复的代码几乎总是代表着对最初设计里彻底分解方面的一个失误。重复代码违背了DRY（Do not repeat yourself）原则，复制粘贴即设计之谬。

冗长的子程序，很少需要用到长度超过一个屏幕的子程序。改善系统的方法之一就是提升其模块性，增加定义完善、命名准确的子程序，让它们各自集中力量做好一件事情。

循环过长或嵌套过深，循环内部的复杂代码常常具备转换为子程序的潜质，这样的改动将有助于对代码的分解，并减少循环的复杂性。

内聚性太差的类，某个类大包大揽了许多彼此无关的任务，那么这个类就该拆分成多个类，每个类负责一组具有内在的相互关联的任务。

类的接口未能提供层次一致的抽象，为了维护接口的完整性，程序员常常会在一怒之下对类动手。

拥有太多参数的参数列表，如果一个程序被分解得很好，那么它的子程序应当小巧，定义精确，且不需要庞大的参数列表。

变化导致对多个类的相同修改，只要在程序中加入一种新的输出类型，就会有15个类需要修改。这表明这些类中的代码应当被重新组织，使修改仅影响到其中的一个类。

case语句需要做相同的修改，多个部分修改。

同时使用的相关数据并未以类的方式进行组织，同样一组数据进行操作，也应当问问自己是否将这些数据及操作组织到一个类里面。

成员函数使用其他类的特征比使用自身类的特征还要多，这一子程序应当被放到另一个类中，然后在原来的类里调用。

过多使用基本数据类型，基本数据类可用于表示真实世界中实体的任意数量。简单数据类型，编译器可以对变量执行类型检查。

某个类无所事事，代码的重构会导致某个已有的类无事可做。

一系列传递流浪数据的子程序，把数据传递给某个子程序，是否仅仅就为了让该子程序把数据转交给另一个子程序。是否这些子程序接口的抽象概念相同。

中间人对象无事可做，某个类中的绝大部分代码只是去调用其他类中的成员函数，考虑是否把这样的中间人去掉，转而直接调用其他的类。

某个类同其它类关系过于亲密，最大限度地减少更改代码对周围的连带影响，那么封装可能是最强有力的工具了。

子程序命名不恰当，名字取得不好，改变其定义的名字，并对所有调用该子程序的地方做相应的修改，然后重新编译。

数据成员被设置为公用，把数据成员设置为公用绝对是一个槽糕的主意。这样会模糊接口和实现之间的界限，其本身也违背了封装的原则。

某个派生类仅使用基类的很少一部分成员函数，派生类的创建仅仅是由于基类碰巧有了该类所需要的子程序，而不是出于逻辑上的派生关系。is-a转变为has-a。

注释被用于解释难懂的代码，注释在程序中扮演了重要的角色，但它不应该被用来为拙劣的代码的存在而辩护。

使用了全局变量，访问器子程序来调用这些数据。

在子程序调用前使用了设置代码，调用后使用了收尾代码。

程序中的一些代码似乎是在将来的某个时候才会用到的。超前设计常常会遭遇很多可预见的问题。超前设计的代码是画蛇添足，增加了程序的复杂性，带来了额外的测试，修补缺陷等工作量。

1、需求不可能定义得很完备，这就意味着程序员对未来需求的猜测很可能是错误的。

2、广泛预见未来需求的所有复杂脉络，这些错综复杂的关系将会埋葬程序员的基本设计构思。

3、耗费了大量事件来让这些所谓的超前设计的代码工作起来，到最后却发现这些代码根本没什么用。

## 特定的重构

### 数据级的重构

以下的重构方法可用于改进变量和其它数据类型的使用。

用具名常量替代神秘数值，使用了数字或字符串表示形式，请将这样的字符使用具名常量替代。

使变量的名字更为清晰且传递更多信息，如果一个变量的名字容易让人对其产生误解，就换个好点的名字。

将表达式内联化，把一个中间变量换成给它赋值的那个表达式本身。

用函数来代替表达式，用一个函数来代替表达式。

引入中间变量，表达式的值赋给中间变量，命名应能准确概况表达式的用途。

用多个单一用途变量代替某多用途变量，多个变量来让它们各司其职吧。

在局部用途中使用局部变量而不是参数，直接创建局部变量来代替参数。

将基础数据类型转换为类，一个基础数据类型需要额外的功能或额外的数据，把该数据转换为一个对象，然后再添加你所需要的类行为。

将一组类型码转换为类或枚举类型，享受严格类型检查所带来的好处。

将一组类型码转换为一个基类机器相应派生类，不同类型相关联不同代码片段。

将数组转换为对象，不同元素具有不同的类型，应该用一个对象来替代它，将数组中的各个元素转化为该类的各个成员。

把群组封装起来，把你的类返回一个只读群集，并且提供相应的添加和删除元素的子程序。

用数据类来代替传统记录，建立一个包含记录成员的类，集中完成对记录的错误检查，持久化和其它与该记录相关的操作。

## 语句级的重构

改善单个语句的使用。

分解布尔表达式，引入名准确的中间变量来简化复杂的布尔表达式，通过变量名更好地说明表达式的含义。

将复杂布尔表达式转换成命名准确的布尔函数，表达式过于复杂，这项重构可以提高可读性。

合并条件语句不同部分中的重复代码片段，完全相同的代码同时出现在一个条件语句的if语句块和else语句块中。

使用break或return而不是循环控制变量。

在嵌套if-then-else语句中一旦知道答案就立即返回，而不是去赋一个返回值。

用多态来替代条件语句，尤其是重复的case语句，结构化程序里很多的case语句中的逻辑都可以被放到继承关系中，通过多态函数调用实现。

创建和使用null对象而不是去检测空值。

## 子程序级重构

提取子程序或方法，内嵌的代码从一个子程序中提取出来，并将其提炼为单独的子程序。

将子程序的代码内联化，如果子程序的程序体很简单，且含义不言自明，在使用的时候直接使用这些代码。

将冗长的子程序转换为类，子程序太长，可以将其转换为类，然后进一步分解，得到的多个子程序来改善该代码的可读性。

用简单算法替代复杂算法，更为简单的算法来替代复杂的算法。

增加参数，需要从调用方获取更多的信息，可以增加它的参数从而为其提供信息。

删除参数，子程序已经不再使用某个参数，就删除它。

将查询操作从修改操作中独立出来，查询操作并不改变对象的状态。

合并相似的子程序，通过参数区分它们的功能，相似子程序的唯一区别或许只是其中用到的常量值不同，请把它们合并到一起。

将行为取决于参数的子程序拆分开来，一个子程序根据输入参数的值执行了不同的代码，考虑将它们拆分成几个可被单独调用的，无须传递特定参数的子程序。

传递整个对象而非特定成员，一个对象的多个值被传递给了一个子程序，考虑是否可修改其接口使之接收整个对象。

传递特定成员而非整个对象，创建对象的唯一理由只是你需要将它传入某个子程序，可以考虑修改一下这个子程序，使之接收特定数据成员而非整个对象。

包装向下转型的操作，子程序返回一个对象时，应当返回其已知的最精确的对象类型。




