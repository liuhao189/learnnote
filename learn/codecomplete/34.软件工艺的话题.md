# 征服复杂性

致力于降低复杂度是软件开发的核心。管理复杂度是软件的首要技术使命。

1、在架构层将系统划分为多个子系统，以便让思绪在某段时间内能专注于系统的一小部分。

2、仔细定义类接口，从而可以忽略类内部的工作机理。

3、保持类接口的抽象性，不必记住不必要的细节。

4、避免全局变量，因为它会大大增加总是需要兼顾的代码比例。

5、避免深层次继承，因为这样会耗费很大精力

6、避免深度嵌套的循环或条件判断，它们都能用简单的控制结构取代，后者占用较少的大脑资源。

7、别用goto，引入了非顺序执行，多数人都不容易弄懂。

8、小心定义错误处理的方法，不要滥用不同的错误处理技术。

9、以系统的观点对待内置的异常机制，后者会成为非线性的控制结构。

10、不要让类过渡膨胀，以至于占据整个程序。

11、子程序应保持短小。

12、使用清楚、不言自明的变量名。

13、传递给子程序的参数数目应尽量少，只保持子程序接口抽象必需的参数。

14、用规范和约定来使大脑从记忆不同代码段的随意性、偶然性差异中解脱出来。

复杂的测试代码放入布尔函数，查找表代替繁琐的逻辑链，也能达到同样目的。

采用编码规范主要也是为了降低复杂度，格式编排，循环，变量命名，建模表示法等方面有统一的考虑，将精力集中于更具挑战性的编码问题上。

各种形式的抽象对于管理复杂度都是很强大的工具。高级语言，子程序，类，程序包和系统。

# 精选开发过程

软件开发与其过程有着很大关系，对于小的项目，程序员的个人才能对软件质量影响最大。

多个程序员参与的项目，组织性的重要程度超过了个人技能。人们一起工作时的方式决定其能力是珠联璧合还是相互抵消。

你所用的过程将决定需要的稳定性，以及它能承受怎样的不稳定。让需求根据灵活性，可以采取增量开发方法，分几次发布功能逐强的软件。

对过程的有意识的掌控同样适用于设计。软件开发中，质量一开始就要逐步建立起来，这与那种先拼凑代码，再通过测试剔除缺陷的思路相悖。测试仅仅说明软件所用的特定方法有缺陷，并不能让软件更有用，更快，更可读或更具扩展性。

不成熟的优化是另一个过程性错误，开始时粗调，后来再进行精调。

关注大型过程和小型过程，意味着应暂停一下去留意自己构建软件的方式。

# 首先为人写程序，其次才是为机器

强调代码可读性。背后的动机是出于同人交流的需要。

可读性对以下方面有正面影响：可理解性，容易复查，错误率，调试，可修改性，开发时间，外在质量。

为了节省编写代码的时间而不顾阅读它的时间，是不经济的。

确保每一件事的做法就是你想成为习惯的那种做法。

私用程序是程序员自用的程序，别人不用，也不会修改，甚至不知道这些程序存在。公用程序则是作者之外的人修改或使用的程序。

前些章节提出的一些技术，好的类名(子程序名，变量名)，精心的布局，短小的子程序。中间结果赋给变量，复杂运算清晰化。

# 深入一门语言去编程，不浮于表面

不要将编程思路局限到所用语言能自动支持的范围，杰出的程序员会考虑他们要干什么，然后才是怎样用手头的工具去实现他们的目标。

避免使用这些有危险的编程特性，而代之以变成规范来弥补语言的弱项。eg，全局变量，goto语句等

你的语言不支持断言，那就编写自己的assert子程序，不支持枚举类型或具名常量，可以按一定方式用全局变量定义自己的枚举或具名常量。

# 借助规范集中注意力

规范是一套用于管理复杂度的智力工具。许多编程细节都有一定的随意性。

使用规范能避免各程序员随意决定导致的理解困难。规范能够精确地传达重要信息。eg：一个字符区分局部变量，类变量和全局变量。

规范可以使你免除各种风险，通过建立禁止使用危险做法的规范，可以在需要用它们时限制这些做法，或者防范它们可能的危险。

规范增加了对低层工作的可预见性。规范能够弥补语言的不足之处。

大型项目，规范过了头，小型项目中常常缺乏规范，没有充分体会到自觉遵守规范时的好处。

# 基于问题域编程

另一个处理复杂度的特殊方式就是尽可能工作于最高的抽象层次，针对编程所要解决的问题来工作，而非针对计算机科学的解决方案。

顶层代码不应充斥于文件，栈，队列，数组，字符有关的细节。顶层代码要说明想解决的问题，应当包括描述性的类名和确切说明干什么的子程序调用。

细节层的信息应隐藏起来，最高层不必关心数据如何保存，无须关注某个注释。

## 将程序划分为不同层次的抽象

必须在某些层次上按照实现层的概念去工作，你可以隔离开工作在实现层次的程序部分和工作在问题域的部分。

1、操作系统的操作和机器指令，高级语言，不必操心最底层，所用语言会自动替你打理好，低级语言，需要自己试着创建一些较高的抽象层次，在其上工作。

2、编程语言结构和工具，该语言的基础数据类型、控制结构等。大多数常见语言多数还提供一些库文件，对操作系统调用的访问等。

3、低层实现结构，算法和数据结构，栈，队列，链表，树，索引文件，顺序文件，排序算法，查找算法。仍要处理太多的细节，以征服复杂性。

4、低层问题域，关于问题相关的原语可用，计算机科学结构与上层问题域代码之间的粘接层。要写这一层的代码，需要构思出解决问题的方法，并创建用以解决问题的各种基本构件。业务对象层或服务层。基本词汇表和构件。

5、高层问题域，基于问题域的术语提供了对问题工作的抽象能力。非计算机专业的人员，在某种程度上是可以看懂的。不依赖于编程语言的某些特性。包含用户的视角。

## 问题域的低层技术

1、在问题域使用类，来实现有实际意义的结构

2、隐藏底层数据类型及其实现细节的信息

3、使用具名常量来说明字符串和文字量的意义。

4、对中间计算结果使用中间变量。用布尔函数使复杂逻辑判断更清晰。

# 当心落石

编程是艺术与科学相互融合产生的一个工程学科，创建软件产品的过程中，它仍需要大量的个人判断。

少数容易出错的类通常是程序最费精力的部分，可能以后还会这样，应考虑重写之。

好的过程不可能开发出易错的代码，编程过程还应包括对架构检查和平衡之后进行复查，设计之后应该有设计评审，编码之后进行代码评审。测试代码阶段，大多数错误应当已消除。

多数设计度量都对设计质量颇有启发性。eg：对于七个的类并不一定就意味着设计得不好，但能说明类有些复杂，子程序多于十个的判断点，三层以上的逻辑嵌套，过多的变量，其它类联系过于紧密，内部代码内聚性不强，都是警告标志。

任何警告信息都应让你质疑程序的质量。

发现代码有重复，或者在若干做的修改很相似。你也应觉得不自在，去质疑子程序或类中的控制是否的当。eg：不能很方便地单独使用某个类，类耦合过紧的警告信息。

考虑程序的缜密程度会对程度质量有决定性作用，关注警告信息与否也直接影响到最终产品的质量。

# 迭代，反反复复，一次又一次

为了获取更好的灵活性，以累积方式逐步建构和交付系统，也是个迭代过程。

使用反复方法评估能够比单一方法来的精确。逐步精化的过程，需要经过反复修正和改进。

如果某处是系统性能提高的瓶颈，就要对代码反复调整。

工程学的一个任务，就是要事半功倍。最后开发阶段的反复，就如同别人只用一元钱就能做的事，你却要用两元钱。

# 应当分离软件与信仰

## 软件先知

一些专业优秀人员往往更容易偏执，革新方法需要公开，才能让别人尝试。尝试这些方法后才能充分证实或反驳之。

## 折中主义

编程问题找出最有效的解决方案时，盲目迷信某种方法只会缩小你的选择余地。软件开发并非确定过程，需要逐步细化的，生硬的过程是不合适的。。

工程学的规划之一就是权衡各种技术，早早将自己的选择限制在单一工具上，就无法做出权衡。

## 试验

试验应贯穿于整个开发过程，但固执会妨碍你这么做，要想有效地试验，应能基于试验结果改变思路，否则试验只会白白浪费时间。

许多顽固的方法源于对错误的畏惧心理，试图没有错误是最大的错误。

都应保持开放的心态，这样才能从开发过程和产品中有所收获。

# 要点

编程的主要目的之一是管理复杂性。

编程过程对最终产品有深远影响。

合作开发要求团队成员之间进行广泛沟通，甚于同计算机的交互，而单人开发则是自我交流，其次才是与计算机。

编程规范一旦滥用，只会雪上加霜，使用得当则能为开发环境带来良好机制，有助于管理复杂性和相互沟通。

编程应基于问题域而非解决方案，这样便于复杂性管理。

注意警告信息，将其作为编程的疑点，因为编程几乎是纯粹的智力活动。

开发时迭代次数越多，产品的质量越好。

墨守成规的方法有悖于高质量的软件开发，请将编程工具箱中填满各种编程工具，不断提高自己挑选合适工具的能力。





